### Estructura de archivos y carpetas ###
.
├── .env.example
├── .eslintrc.js
├── .github
│   └── workflows
│       └── generate_context.yml
├── .gitignore
├── .prettierrc
├── .vscode
│   ├── extensions.json
│   └── settings.json
├── README.md
├── contexto_repo.txt
├── database
│   └── migrations
│       ├── 1715004771671-CreatePermissionsTable.ts
│       ├── 1715004780671-CreateRolesTable.ts
│       ├── 1715004780681-CreatePermissionRoleTable.ts
│       ├── 1715004781671-CreateUsersTable.ts
│       ├── 1715004781771-CreateRoleUserTable.ts
│       └── 1715004781772-CreatePermissionUserTable.ts
├── docker-compose.yml
├── nest-cli.json
├── ormconfig.ts
├── package.json
├── src
│   ├── app.module.ts
│   ├── common
│   │   ├── adapters
│   │   │   ├── configuration
│   │   │   │   ├── domain
│   │   │   │   │   ├── configs
│   │   │   │   │   │   ├── app-config.type.ts
│   │   │   │   │   │   ├── database-config.type.ts
│   │   │   │   │   │   ├── index.ts
│   │   │   │   │   │   ├── jwt-config.type.ts
│   │   │   │   │   │   └── type-orm-config.type.ts
│   │   │   │   │   ├── configuration.type.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── index.ts
│   │   │   │   └── infrastructure
│   │   │   │       ├── configs
│   │   │   │       │   ├── app.config.ts
│   │   │   │       │   ├── database.config.ts
│   │   │   │       │   ├── index.ts
│   │   │   │       │   ├── jwt.config.ts
│   │   │   │       │   └── type-orm.config.ts
│   │   │   │       ├── configuration.module.ts
│   │   │   │       ├── configuration.service.ts
│   │   │   │       └── index.ts
│   │   │   ├── database
│   │   │   │   ├── index.ts
│   │   │   │   └── infrastructure
│   │   │   │       ├── database.module.ts
│   │   │   │       ├── index.ts
│   │   │   │       └── typeorm-config.service.ts
│   │   │   ├── exception
│   │   │   │   ├── domain
│   │   │   │   │   ├── exception-providers.enum.ts
│   │   │   │   │   ├── exeption-service.interface.ts
│   │   │   │   │   ├── format-exception-message.interface.ts
│   │   │   │   │   ├── index.ts
│   │   │   │   │   └── internal-error-message.interface.ts
│   │   │   │   ├── index.ts
│   │   │   │   └── infrastructure
│   │   │   │       ├── custom-exceptions
│   │   │   │       │   ├── bad-request-custom.exception.ts
│   │   │   │       │   ├── base-custom.exception.ts
│   │   │   │       │   ├── forbidden-custom.exception.ts
│   │   │   │       │   ├── index.ts
│   │   │   │       │   ├── internal-server-error-custom.exception.ts
│   │   │   │       │   └── unauthorized-custom.exception.ts
│   │   │   │       ├── exception.module.ts
│   │   │   │       ├── exception.service.ts
│   │   │   │       ├── filters
│   │   │   │       │   ├── all-exception.filter.ts
│   │   │   │       │   ├── base-custom-exception.filter.ts
│   │   │   │       │   ├── index.ts
│   │   │   │       │   └── validation-exception.filter.ts
│   │   │   │       └── index.ts
│   │   │   ├── hash
│   │   │   │   ├── domain
│   │   │   │   │   ├── hash-providers.enum.ts
│   │   │   │   │   ├── hash-service.interface.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── index.ts
│   │   │   │   └── infrastructure
│   │   │   │       ├── hash-bcrypt.service.ts
│   │   │   │       ├── hash.module.ts
│   │   │   │       └── index.ts
│   │   │   ├── index.ts
│   │   │   ├── logger
│   │   │   │   ├── domain
│   │   │   │   │   ├── index.ts
│   │   │   │   │   ├── logger-providers.enum.ts
│   │   │   │   │   ├── logger-service.interface.ts
│   │   │   │   │   └── logger.type.ts
│   │   │   │   ├── index.ts
│   │   │   │   └── infrastructure
│   │   │   │       ├── index.ts
│   │   │   │       ├── logger.module.ts
│   │   │   │       └── logger.service.ts
│   │   │   └── token
│   │   │       ├── domain
│   │   │       │   ├── index.ts
│   │   │       │   ├── token-payload.type.ts
│   │   │       │   ├── token-providers.enum.ts
│   │   │       │   └── token-service.interface.ts
│   │   │       ├── index.ts
│   │   │       └── infrastructure
│   │   │           ├── index.ts
│   │   │           ├── jwt-config.service.ts
│   │   │           ├── strategies
│   │   │           │   ├── index.ts
│   │   │           │   └── jwt-passport.strategy.ts
│   │   │           ├── token-jwt.service.ts
│   │   │           └── token.module.ts
│   │   ├── helpers
│   │   │   ├── application
│   │   │   │   ├── general-policy.helper.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── paginated-resource.helper.ts
│   │   │   │   └── paginated-resource.precenter.ts
│   │   │   ├── domain
│   │   │   │   ├── enums
│   │   │   │   │   ├── filter-rule.enum.ts
│   │   │   │   │   ├── general-statuses.enum.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── interfaces
│   │   │   │   │   ├── base-use-case.interface.ts
│   │   │   │   │   ├── error.interface.ts
│   │   │   │   │   └── index.ts
│   │   │   │   └── types
│   │   │   │       ├── filtering.type.ts
│   │   │   │       ├── find-all-fields.dto.ts
│   │   │   │       ├── find-one-by-fields.dto.ts
│   │   │   │       ├── index.ts
│   │   │   │       ├── paginated-resource.type.ts
│   │   │   │       ├── pagination.type.ts
│   │   │   │       ├── prop-values.type.ts
│   │   │   │       ├── response-format.type.ts
│   │   │   │       ├── response.type.ts
│   │   │   │       └── sorting.type.ts
│   │   │   ├── index.ts
│   │   │   └── infrastructure
│   │   │       ├── decorators
│   │   │       │   ├── filtering-params.decorator.ts
│   │   │       │   ├── index.ts
│   │   │       │   ├── pagination-params.decorator.ts
│   │   │       │   ├── request-id.decorator.ts
│   │   │       │   └── sorting-params.decorator.ts
│   │   │       ├── get-order-type-orm.helper.ts
│   │   │       ├── get-where-type-orm.helper.ts
│   │   │       ├── index.ts
│   │   │       ├── interceptors
│   │   │       │   ├── index.ts
│   │   │       │   ├── logging.Interceptor.ts
│   │   │       │   └── response.interceptor.ts
│   │   │       └── middlewares
│   │   │           ├── index.ts
│   │   │           └── request-id.middleware.ts
│   │   └── index.ts
│   ├── main.ts
│   ├── modules
│   │   ├── auth
│   │   │   ├── application
│   │   │   │   ├── index.ts
│   │   │   │   └── sign-in.use-case.ts
│   │   │   ├── domain
│   │   │   │   ├── enums
│   │   │   │   │   ├── auth-errors.codes.ts
│   │   │   │   │   ├── auth-usecases.enum.ts
│   │   │   │   │   └── index.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── interfaces
│   │   │   │   │   ├── index.ts
│   │   │   │   │   └── sign-in-use-case.interface.ts
│   │   │   │   └── types
│   │   │   │       ├── auth-user.type.ts
│   │   │   │       ├── auth.type.ts
│   │   │   │       ├── index.ts
│   │   │   │       └── sign-in.type.ts
│   │   │   └── infrastructure
│   │   │       ├── api
│   │   │       │   ├── index.ts
│   │   │       │   └── sign-in.controller.ts
│   │   │       ├── auth.module.ts
│   │   │       ├── decorators
│   │   │       │   ├── auth.decorator.ts
│   │   │       │   ├── get-auth-user.decorator.ts
│   │   │       │   ├── index.ts
│   │   │       │   └── permission-protected.decorator.ts
│   │   │       ├── dto
│   │   │       │   ├── index.ts
│   │   │       │   └── sign-in.dto.ts
│   │   │       ├── guards
│   │   │       │   ├── index.ts
│   │   │       │   ├── jwt-auth.guard.ts
│   │   │       │   └── user-permission.guard.ts
│   │   │       └── index.ts
│   │   ├── permissions
│   │   │   ├── application
│   │   │   │   ├── find-all-permissions.use-case.ts
│   │   │   │   └── index.ts
│   │   │   ├── domain
│   │   │   │   ├── index.ts
│   │   │   │   ├── permission-errors.codes.ts
│   │   │   │   ├── permission-permissions.enum.ts
│   │   │   │   ├── permission-providers.enum.ts
│   │   │   │   ├── permission-repository.interface.ts
│   │   │   │   └── types
│   │   │   │       ├── create-permission.type.ts
│   │   │   │       ├── index.ts
│   │   │   │       ├── permission-filter.type.ts
│   │   │   │       └── permission.type.ts
│   │   │   └── infrastructure
│   │   │       ├── api
│   │   │       │   ├── find-all-permissions.controller.ts
│   │   │       │   └── index.ts
│   │   │       ├── index.ts
│   │   │       ├── permission.presenter.ts
│   │   │       ├── permissions.module.ts
│   │   │       ├── persistence
│   │   │       │   ├── index.ts
│   │   │       │   ├── permission-typeorm.repository.ts
│   │   │       │   └── permission.entity.ts
│   │   │       └── seeders
│   │   │           ├── index.ts
│   │   │           └── permissions.seeder.ts
│   │   ├── roles
│   │   │   ├── application
│   │   │   │   ├── delete-role.use-case.ts
│   │   │   │   ├── find-all-roles.use-case.ts
│   │   │   │   ├── find-by-role.use-case.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── store-role.use-case.ts
│   │   │   │   └── update-role.use-case.ts
│   │   │   ├── domain
│   │   │   │   ├── create-role.type.ts
│   │   │   │   ├── index.ts
│   │   │   │   ├── role-errors.codes.ts
│   │   │   │   ├── role-filter.type.ts
│   │   │   │   ├── role-permissions.enum.ts
│   │   │   │   ├── role-providers.enum.ts
│   │   │   │   ├── role-repository.interface.ts
│   │   │   │   ├── role.type.ts
│   │   │   │   └── update-role.type.ts
│   │   │   └── infrastructure
│   │   │       ├── api
│   │   │       │   ├── delete-role.controller.ts
│   │   │       │   ├── find-all-roles.controller.ts
│   │   │       │   ├── find-by-role.controller.ts
│   │   │       │   ├── index.ts
│   │   │       │   ├── store-role.controller.ts
│   │   │       │   └── update-role.controller.ts
│   │   │       ├── dto
│   │   │       │   ├── create-role.dto.ts
│   │   │       │   ├── index.ts
│   │   │       │   └── update-role.dto.ts
│   │   │       ├── index.ts
│   │   │       ├── persistence
│   │   │       │   ├── index.ts
│   │   │       │   ├── role-typeorm.repository.ts
│   │   │       │   └── role.entity.ts
│   │   │       ├── role.presenter.ts
│   │   │       ├── roles.module.ts
│   │   │       └── seeders
│   │   │           ├── index.ts
│   │   │           └── roles.seeder.ts
│   │   └── users
│   │       ├── application
│   │       │   ├── delete-user.use-case.ts
│   │       │   ├── find-all-users.use-case.ts
│   │       │   ├── find-by-user.use-case.ts
│   │       │   ├── index.ts
│   │       │   ├── store-user.use-case.ts
│   │       │   ├── update-user.use-case.ts
│   │       │   ├── use-cases
│   │       │   │   └── .gitkeep
│   │       │   └── user.policy.ts
│   │       ├── domain
│   │       │   ├── create-user-repository.type.ts
│   │       │   ├── create-user.type.ts
│   │       │   ├── index.ts
│   │       │   ├── update-user.type.ts
│   │       │   ├── user-errors.codes.ts
│   │       │   ├── user-filter.type.ts
│   │       │   ├── user-permissions.enum.ts
│   │       │   ├── user-providers.enum.ts
│   │       │   ├── user-repository.interface.ts
│   │       │   └── user.type.ts
│   │       └── infrastructure
│   │           ├── api
│   │           │   ├── delete-user.controller.ts
│   │           │   ├── find-all-users.controller.ts
│   │           │   ├── find-by-user.controller.ts
│   │           │   ├── index.ts
│   │           │   ├── store-user.controller.ts
│   │           │   └── update-user.controller.ts
│   │           ├── dto
│   │           │   ├── create-user.dto.ts
│   │           │   ├── index.ts
│   │           │   └── update-user.dto.ts
│   │           ├── index.ts
│   │           ├── persistence
│   │           │   ├── index.ts
│   │           │   ├── user-typeorm.repository.ts
│   │           │   └── user.entity.ts
│   │           ├── seeders
│   │           │   ├── dev-users.seeder.ts
│   │           │   ├── index.ts
│   │           │   └── prod-users.seeder.ts
│   │           ├── user.presenter.ts
│   │           └── users.module.ts
│   └── seed.ts
├── test
│   ├── app.e2e-spec.ts
│   └── jest-e2e.json
├── tsconfig.build.json
└── tsconfig.json

79 directories, 242 files
\n### Contenido de archivos clave ###

----- ./docker-compose.yml -----

services:
    pgsql:
        image: 'postgres:13'
        ports:
            - '${DB_PORT:-5432}:5432'
        environment:
            PGPASSWORD: '${DB_PASSWORD:-secret}'
            POSTGRES_DB: '${DB_DATABASE}'
            POSTGRES_USER: '${DB_USERNAME}'
            POSTGRES_PASSWORD: '${DB_PASSWORD:-secret}'
        volumes:
            - pgsql:/var/lib/postgresql/data
        networks:
            - app
        healthcheck:
            test: ["CMD", "pg_isready", "-q", "-d", "${DB_DATABASE}", "-U", "${DB_USERNAME}"]
            retries: 3
            timeout: 5s

networks:
    app:
        driver: bridge
volumes:
    pgsql:
        driver: local

----- ./tsconfig.build.json -----

{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}

----- ./README.md -----

<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="200" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).

----- ./tsconfig.json -----

{
  "ts-node": {
    "require": ["tsconfig-paths/register"]
  },
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "paths": {
      // Common
      "@common/helpers/*": ["./src/common/helpers/*"],
      "@common/adapters/configuration/*": [
        "./src/common/adapters/configuration/*"
      ],
      "@common/adapters/database/*": ["./src/common/adapters/database/*"],
      "@common/adapters/logger/*": ["./src/common/adapters/logger/*"],
      "@common/adapters/exception/*": ["./src/common/adapters/exception/*"],
      "@common/adapters/hash/*": ["./src/common/adapters/hash/*"],
      "@common/adapters/token/*": ["./src/common/adapters/token/*"],

      // Modules
      "@modules/permissions/*": ["./src/modules/permissions/*"],
      "@modules/roles/*": ["./src/modules/roles/*"],
      "@modules/users/*": ["./src/modules/users/*"],
      "@modules/auth/*": ["./src/modules/auth/*"]
    }
  }
}

----- ./package.json -----

{
  "name": "nest-clean-architecture",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "typeorm": "ts-node -r tsconfig-paths/register ./node_modules/typeorm/cli",
    "typeorm:migrate": "npm run typeorm -- migration:run -d ormconfig.ts",
    "typeorm:revert": "npm run typeorm -- migration:revert -d ormconfig.ts",
    "typeorm:drop": "npm run typeorm -- schema:drop -d ormconfig.ts",
    "typeorm:create": "npm run typeorm migration:create",
    "seed": "nest start --entryFile src/seed",
    "typeorm:migrate:fresh:seed": "npm run typeorm:drop && npm run typeorm:migrate && npm run seed"
  },
  "dependencies": {
    "@nestjs/common": "^11.0.10",
    "@nestjs/config": "^4.0.0",
    "@nestjs/core": "^11.0.10",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/passport": "^11.0.5",
    "@nestjs/platform-express": "^11.0.10",
    "@nestjs/typeorm": "^11.0.0",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "pg": "^8.13.3",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.2",
    "typeorm": "0.3.20",
    "uuid": "^11.1.0"
  },
  "devDependencies": {
    "@faker-js/faker": "^9.5.0",
    "@nestjs/cli": "^11.0.5",
    "@nestjs/schematics": "^11.0.1",
    "@nestjs/testing": "^11.0.10",
    "@types/bcrypt": "^5.0.2",
    "@types/express": "^5.0.0",
    "@types/jest": "29.5.14",
    "@types/node": "^22.13.5",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "@types/uuid": "^10.0.0",
    "@typescript-eslint/eslint-plugin": "^8.25.0",
    "@typescript-eslint/parser": "^8.25.0",
    "eslint": "^9.21.0",
    "eslint-config-prettier": "^10.0.2",
    "eslint-plugin-prettier": "^5.2.3",
    "jest": "29.7.0",
    "prettier": "^3.5.2",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "29.2.6",
    "ts-loader": "^9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}

----- ./.prettierrc -----

{
  "singleQuote": true,
  "trailingComma": "all"
}
----- ./.vscode/settings.json -----

{
  "[typescript]": {
    "editor.defaultFormatter": "esbenp.prettier-vscode"
  },
  "editor.formatOnSave": true,
  "editor.tabSize": 2,
  "jest.runMode": "on-demand"
}

----- ./.vscode/extensions.json -----

{
  "recommendations": [
    "dbaeumer.vscode-eslint",
    "esbenp.prettier-vscode",
    "guilhermetheodoro.typescript-indexing"
  ]
}

----- ./ormconfig.ts -----

import { join } from 'path';
import { DataSource } from 'typeorm';
import * as dotenv from 'dotenv';

dotenv.config();

const migrationsPath = join(
  __dirname,
  'database',
  'migrations',
  '**',
  '*.{ts,js}',
);

export default new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST,
  port: parseInt(process.env.DB_PORT),
  username: process.env.DB_USERNAME,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_DATABASE,
  logging: process.env.TYPEORM_LOGGING === 'true',
  synchronize: false,
  migrations: [migrationsPath],
});

----- ./.eslintrc.js -----

module.exports = {
  parser: '@typescript-eslint/parser',
  parserOptions: {
    project: 'tsconfig.json',
    tsconfigRootDir: __dirname,
    sourceType: 'module',
  },
  plugins: ['@typescript-eslint/eslint-plugin'],
  extends: [
    'plugin:@typescript-eslint/recommended',
    'plugin:prettier/recommended',
  ],
  root: true,
  env: {
    node: true,
    jest: true,
  },
  ignorePatterns: ['.eslintrc.js'],
  rules: {
    '@typescript-eslint/interface-name-prefix': 'off',
    '@typescript-eslint/explicit-function-return-type': 'off',
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'off',
  },
};

----- ./nest-cli.json -----

{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}

----- ./.gitignore -----

# Created by https://www.toptal.com/developers/gitignore/api/visualstudiocode,windows,linux,macos,node,dotenv
# Edit at https://www.toptal.com/developers/gitignore?templates=visualstudiocode,windows,linux,macos,node,dotenv

### dotenv ###
.env

### Linux ###
*~

# temporary files which can be created if a process still has a handle open of a deleted file
.fuse_hidden*

# KDE directory preferences
.directory

# Linux trash folder which might appear on any partition or disk
.Trash-*

# .nfs files are created when an open file is removed but is still being accessed
.nfs*

### macOS ###
# General
.DS_Store
.AppleDouble
.LSOverride

# Icon must end with two \r
Icon


# Thumbnails
._*

# Files that might appear in the root of a volume
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent

# Directories potentially created on remote AFP share
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

### macOS Patch ###
# iCloud generated files
*.icloud

### Node ###
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

### Node Patch ###
# Serverless Webpack directories
.webpack/

# Optional stylelint cache

# SvelteKit build / generate output
.svelte-kit

### VisualStudioCode ###
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
!.vscode/*.code-snippets

# Local History for Visual Studio Code
.history/

# Built Visual Studio Code Extensions
*.vsix

### VisualStudioCode Patch ###
# Ignore all local history of files
.history
.ionide

### Windows ###
# Windows thumbnail cache files
Thumbs.db
Thumbs.db:encryptable
ehthumbs.db
ehthumbs_vista.db

# Dump file
*.stackdump

# Folder config file
[Dd]esktop.ini

# Recycle Bin used on file shares
$RECYCLE.BIN/

# Windows Installer files
*.cab
*.msi
*.msix
*.msm
*.msp

# Windows shortcuts
*.lnk

# End of https://www.toptal.com/developers/gitignore/api/visualstudiocode,windows,linux,macos,node,dotenv
----- ./.env.example -----

APP_NAME=App
APP_ENV=dev
APP_DEBUG=true
APP_PORT=3000
APP_URL="http://localhost"

DB_TYPE=postgres
DB_HOST=localhost
DB_PORT=5432
DB_DATABASE=pos
DB_USERNAME=admin
DB_PASSWORD=admin
TYPEORM_LOGGING=true

JWT_SECRET=
JWT_EXPIRATION_TIME='1h'
----- ./.github/workflows/generate_context.yml -----

name: Actualizar Contexto y Crear Pull Request

on:
  push:
    branches:
      - main
    paths-ignore:
      - 'contexto_repo.txt' # Evita que el workflow se dispare por cambios en este archivo

jobs:
  create-pull-request:
    runs-on: ubuntu-latest
    steps:
      - name: 📥 Clonar el repositorio
        uses: actions/checkout@v3

      - name: 📝 Generar lista de archivos y contenido (Filtrado)
        run: |
          echo "### Estructura de archivos y carpetas ###" > contexto_repo.txt
          tree -a -I '.git|node_modules|package-lock.json' >> contexto_repo.txt

          echo "\n### Contenido de archivos clave ###" >> contexto_repo.txt

          # Incluir archivos de configuración importantes (SIN duplicados)
          find . -type f \( \
            -name ".env.example" \
            -o -name "package.json" \
            -o -name "tsconfig.json" \
            -o -name "tsconfig.build.json" \
            -o -name "nest-cli.json" \
            -o -name "docker-compose.yml" \
            -o -name "ormconfig.ts" \
            -o -name ".eslintrc.js" \
            -o -name ".prettierrc" \
            -o -name ".gitignore" \
            -o -path "./.vscode/extensions.json" \
            -o -path "./.vscode/settings.json" \
            -o -path "./.github/workflows/generate_context.yml" \
            -o -name "README.md" \
            \) ! -path "./node_modules/*" ! -path "./.git/*" \
            -exec echo -e "\n----- {} -----\n" \; -exec cat {} \; >> contexto_repo.txt

          # Incluir archivos de código fuente (SIN duplicados)
          echo "\n### Contenido de archivos de código fuente ###" >> contexto_repo.txt
          find src/ -type f \( -name "*.ts" -o -name "*.json" -o -name "*.md" -o -name "*.yml" -o -name "*.yaml" \) \
            ! -path "./node_modules/*" ! -path "./.git/*" \
            -exec echo -e "\n----- {} -----\n" \; -exec cat {} \; >> contexto_repo.txt

      - name: 🔄 Crear nueva rama y hacer commit
        run: |
          git config --global user.name "github-actions"
          git config --global user.email "actions@github.com"

          # Generar un nombre único para la nueva rama
          BRANCH_NAME="update-context-$(date +%Y%m%d%H%M%S)"
          echo "BRANCH_NAME=$BRANCH_NAME" >> $GITHUB_ENV  # Guardar variable en el entorno

          git checkout -b $BRANCH_NAME
          git add contexto_repo.txt
          git commit -m "🔄 Actualización automática del contexto del repo" || exit 0
          git push origin $BRANCH_NAME
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 🔀 Crear Pull Request automático
        uses: repo-sync/pull-request@v2
        with:
          source_branch: ${{ env.BRANCH_NAME }} # Usar la rama generada
          destination_branch: 'main'
          pr_title: '🔄 Actualización automática del contexto del repo'
          pr_body: 'Este Pull Request fue generado automáticamente para actualizar `contexto_repo.txt` con la última estructura y contenido del repositorio.'
          pr_label: 'automated-pr'
          github_token: ${{ secrets.GITHUB_TOKEN }}
\n### Contenido de archivos de código fuente ###

----- src/app.module.ts -----

import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { RequestIdMiddleware } from '@common/helpers/infrastructure/middlewares';
import { HashModule } from '@common/adapters/hash/infrastructure';
import { ConfigurationModule } from '@common/adapters/configuration/infrastructure';
import { DatabaseModule } from '@common/adapters/database/infrastructure';
import { LoggerModule } from '@common/adapters/logger/infrastructure';
import { ExceptionModule } from '@common/adapters/exception/infrastructure';
import { TokenModule } from '@common/adapters/token/infrastructure';
import { PermissionModule } from '@modules/permissions/infrastructure';
import { RoleModule } from '@modules/roles/infrastructure';
import { UserModule } from '@modules/users/infrastructure';
import { AuthModule } from '@modules/auth/infrastructure';

@Module({
  imports: [
    // Common
    ConfigurationModule,
    DatabaseModule,
    LoggerModule,
    ExceptionModule,
    HashModule,
    TokenModule,

    // Modules
    PermissionModule,
    RoleModule,
    UserModule,
    AuthModule,
  ],
})
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(RequestIdMiddleware).forRoutes('*');
  }
}

----- src/seed.ts -----

import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { PermissionProvidersEnum } from '@modules/permissions/domain';
import { RoleProvidersEnum } from '@modules/roles/domain';
import { UserProvidersEnum } from '@modules/users/domain';

async function bootstrap() {
  const app = await NestFactory.createApplicationContext(AppModule);

  const PermissionSeeder = app.get(PermissionProvidersEnum.PERMISSION_SEEDER);
  const permissions = await PermissionSeeder.seed();

  const roleSeeder = app.get(RoleProvidersEnum.ROLE_SEEDER);
  const roles = await roleSeeder.seed(permissions);

  const userSeeder = app.get(UserProvidersEnum.USER_SEEDER);
  await userSeeder.seed(roles);

  await app.close();
}

bootstrap().catch((err) => console.error(err));

----- src/main.ts -----

import { NestFactory } from '@nestjs/core';
import { ValidationPipe } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import {
  AppConfigType,
  ConfigurationType,
} from '@common/adapters/configuration/domain';
import {
  ResponseInterceptor,
  LoggingInterceptor,
} from '@common/helpers/infrastructure';
import { LoggerProvidersEnum } from '@common/adapters/logger/domain';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { cors: true });
  const logger = app.get(LoggerProvidersEnum.LOGGER_SERVICE);
  const configService = app.get(ConfigService<ConfigurationType>);
  const { port } = configService.get<AppConfigType>('app');

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
    }),
  );

  app.useGlobalInterceptors(new LoggingInterceptor(logger));
  app.useGlobalInterceptors(new ResponseInterceptor());

  await app.listen(port);

  logger.log({
    context: 'Bootstrap',
    message: `🚀 Server running on port: ${port}`,
  });
}

bootstrap();

----- src/common/helpers/infrastructure/middlewares/index.ts -----

export * from './request-id.middleware';

----- src/common/helpers/infrastructure/middlewares/request-id.middleware.ts -----

import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class RequestIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // Si el cliente ya envía un request id, lo usamos; si no, generamos uno.
    const requestId = req.headers['x-request-id'] || uuidv4();

    // Adjuntamos el request id a los headers de la petición para que esté disponible en el ciclo de vida de la misma.
    req.headers['x-request-id'] = requestId;
    // Opcional: También lo agregamos en la respuesta para que el cliente pueda visualizarlo.
    res.setHeader('x-request-id', requestId as string);

    next();
  }
}

----- src/common/helpers/infrastructure/decorators/pagination-params.decorator.ts -----

import {
  BadRequestException,
  ExecutionContext,
  createParamDecorator,
} from '@nestjs/common';
import { Request } from 'express';

export const PaginationParams = createParamDecorator(
  (data, ctx: ExecutionContext) => {
    const req: Request = ctx.switchToHttp().getRequest();
    const page = parseInt(req.query.page as string) || 1;
    const size = parseInt(req.query.size as string) || 10;

    if (page < 0 || size < 0) {
      throw new BadRequestException('Invalid pagination params');
    }

    if (size > 100) {
      throw new BadRequestException(
        'Invalid pagination params: Max size is 100',
      );
    }

    return { page, size };
  },
);

----- src/common/helpers/infrastructure/decorators/sorting-params.decorator.ts -----

import {
  BadRequestException,
  createParamDecorator,
  ExecutionContext,
} from '@nestjs/common';
import { Request } from 'express';
// import { SortingType } from '../../domain';

export const SortingParams = <T>(
  ...validParams: (keyof T)[]
): ParameterDecorator => {
  return createParamDecorator((data: unknown, ctx: ExecutionContext) => {
    const req: Request = ctx.switchToHttp().getRequest();
    const sort = req.query.sort as string;
    if (!sort) return null;

    // if (typeof validParams != 'object')
    //   throw new BadRequestException('Invalid sort parameter');

    const sortPattern = /^([a-zA-Z0-9]+)\|(asc|desc)$/;

    if (!sort.match(sortPattern))
      throw new BadRequestException('Invalid sort parameter');

    const [property, direction] = sort.split('|');

    if (!validParams.find((key) => key === property))
      throw new BadRequestException(`Invalid sort property: ${property}`);

    return { property, direction };
  })();
};

// export const SortingParams = createParamDecorator(
//   <T>(validParams: (keyof T)[], ctx: ExecutionContext): SortingType => {
//     const req: Request = ctx.switchToHttp().getRequest();
//     const sort = req.query.sort as string;
//     if (!sort) return null;

//     // if (typeof validParams != 'object')
//     //   throw new BadRequestException('Invalid sort parameter');

//     const sortPattern = /^([a-zA-Z0-9]+)\|(asc|desc)$/;

//     if (!sort.match(sortPattern))
//       throw new BadRequestException('Invalid sort parameter');

//     const [property, direction] = sort.split('|');

//     if (!validParams.find((key) => key === property))
//       throw new BadRequestException(`Invalid sort property: ${property}`);

//     return { property, direction };
//   },
// );

----- src/common/helpers/infrastructure/decorators/request-id.decorator.ts -----

import { createParamDecorator, ExecutionContext } from '@nestjs/common';

export const RequestId = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): string => {
    const request = ctx.switchToHttp().getRequest();
    return request.headers['x-request-id'];
  },
);

----- src/common/helpers/infrastructure/decorators/filtering-params.decorator.ts -----

import {
  BadRequestException,
  ExecutionContext,
  createParamDecorator,
} from '@nestjs/common';
import { Request } from 'express';
import { FilterRuleEnum } from '../../domain';

export const FilteringParams = <T>(
  ...validParams: (keyof T)[]
): ParameterDecorator => {
  return createParamDecorator((data: unknown, ctx: ExecutionContext) => {
    const req: Request = ctx.switchToHttp().getRequest();
    const filter = req.query;
    const properties = validParams.reduce((acc, property) => {
      if (!(filter[property] as string)) return acc;

      const val = filter[property] as string;
      const [rule, value] = val.split('|');

      if (!Object.values(FilterRuleEnum).includes(rule as FilterRuleEnum))
        throw new BadRequestException(
          `Invalid filter rule: ${rule} for ${val}`,
        );

      return [...acc, { property, rule, value }];
    }, []);

    return properties;
  })();
};

----- src/common/helpers/infrastructure/decorators/index.ts -----

export * from './filtering-params.decorator';
export * from './pagination-params.decorator';
export * from './request-id.decorator';
export * from './sorting-params.decorator';

----- src/common/helpers/infrastructure/get-order-type-orm.helper.ts -----

import { SortingType } from '../domain';

export const getOrderTypeOrmHelper = <T>(sort: SortingType<T>) =>
  sort ? { [sort.property]: sort.direction } : {};

----- src/common/helpers/infrastructure/interceptors/response.interceptor.ts -----

import { Request } from 'express';
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable, map } from 'rxjs';
import { ResponseFormatType } from '../../domain';

@Injectable()
export class ResponseInterceptor<T>
  implements NestInterceptor<T, ResponseFormatType<T>>
{
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const now = Date.now();
    const httpCtx = context.switchToHttp();
    const request = httpCtx.getRequest<Request>();

    return context.getType() === 'http'
      ? next.handle().pipe(
          map((data) => ({
            data,
            path: request.path,
            duration: `${Date.now() - now}ms`,
            method: request.method,
          })),
        )
      : next.handle();
  }
}

----- src/common/helpers/infrastructure/interceptors/logging.Interceptor.ts -----

import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Request } from 'express';
import { LoggerService } from '@common/adapters/logger/infrastructure';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  private readonly loggerContext = LoggingInterceptor.name;

  constructor(private readonly logger: LoggerService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<void> {
    const now = Date.now();
    const httpCtx = context.switchToHttp();

    const request = httpCtx.getRequest<Request>();

    const ip = this.getIP(request);
    const requestId = request.headers['x-request-id'] as string;

    this.logger.log({
      context: `Incoming Request on ${request.path}`,
      message: { method: request.method, ip: ip },
      requestId,
    });

    return next.handle().pipe(
      tap(() => {
        this.logger.log({
          context: `End Request for ${request.path}`,
          requestId,
          message: {
            method: request.method,
            ip: ip,
            duration: `${Date.now() - now}ms`,
          },
        });
      }),
    );
  }

  private getIP(request: Request): string {
    let ip: string;
    const ipAddr = request.headers['X-Forwarded-For'] as string;

    if (ipAddr) {
      const list = ipAddr.split(',');

      ip = list[list.length - 1];
    } else {
      ip = request.socket.remoteAddress;
    }

    return ip.replace('::ffff:', '');
  }
}

----- src/common/helpers/infrastructure/interceptors/index.ts -----

export * from './logging.Interceptor';
export * from './response.interceptor';

----- src/common/helpers/infrastructure/index.ts -----

export * from './decorators';
export * from './get-order-type-orm.helper';
export * from './get-where-type-orm.helper';
export * from './interceptors';
export * from './middlewares';

----- src/common/helpers/infrastructure/get-where-type-orm.helper.ts -----

import {
  IsNull,
  MoreThan,
  MoreThanOrEqual,
  Not,
  LessThan,
  LessThanOrEqual,
  ILike,
  In,
} from 'typeorm';
import { FilterRuleEnum, FilteringType } from '../domain';

export const getWhereTypeOrmHelper = <T>(
  filters: FilteringType<T>[] | FilteringType<T>,
) => {
  if (!filters) return {};

  return Array.isArray(filters)
    ? filters.map((filter) => {
        return getValidFilter<T>(filter);
      })
    : getValidFilter<T>(filters);
};

const getValidFilter = <T>(filter: FilteringType<T>) => {
  const { property, rule, value } = filter;
  const propertyString = property as string;
  const ruleString = rule.toString();

  const filterFunction = filterMap[ruleString];
  if (filterFunction) {
    return filterFunction(propertyString, value);
  }
};

const filterMap = {
  [FilterRuleEnum.IS_NULL]: (property: string) => ({ [property]: IsNull() }),
  [FilterRuleEnum.IS_NOT_NULL]: (property: string) => ({
    [property]: Not(IsNull()),
  }),
  [FilterRuleEnum.EQUALS]: (property: string, value: unknown) => ({
    [property]: value,
  }),
  [FilterRuleEnum.NOT_EQUALS]: (property: string, value: unknown) => ({
    [property]: Not(value),
  }),
  [FilterRuleEnum.GREATER_THAN]: (property: string, value: unknown) => ({
    [property]: MoreThan(value),
  }),
  [FilterRuleEnum.GREATER_THAN_OR_EQUALS]: (
    property: string,
    value: unknown,
  ) => ({
    [property]: MoreThanOrEqual(value),
  }),
  [FilterRuleEnum.LESS_THAN]: (property: string, value: unknown) => ({
    [property]: LessThan(value),
  }),
  [FilterRuleEnum.LESS_THAN_OR_EQUALS]: (property: string, value: unknown) => ({
    [property]: LessThanOrEqual(value),
  }),
  [FilterRuleEnum.LIKE]: (property: string, value: unknown) => ({
    [property]: ILike(`%${value}%`),
  }),
  [FilterRuleEnum.NOT_LIKE]: (property: string, value: unknown) => ({
    [property]: Not(ILike(`%${value}%`)),
  }),
  [FilterRuleEnum.IN]: (property: string, value: unknown) => ({
    [property]: In((value as string).split(',')),
  }),
  [FilterRuleEnum.NOT_IN]: (property: string, value: unknown) => ({
    [property]: Not(In((value as string).split(','))),
  }),
};

----- src/common/helpers/domain/types/response-format.type.ts -----

import { ResponseType } from './response.type';

export class ResponseFormatType<T> implements ResponseType<T> {
  // isArray: boolean;
  path: string;
  duration: string;
  method: string;
  data: T;
}

----- src/common/helpers/domain/types/response.type.ts -----

export type ResponseType<T> = {
  // isArray: boolean;
  path: string;
  duration: string;
  method: string;
  data: T;
};

----- src/common/helpers/domain/types/prop-values.type.ts -----

export type PropValuesType<T> = {
  [K in keyof T]: T[K];
};

----- src/common/helpers/domain/types/sorting.type.ts -----

export type SortingType<T> = {
  property: keyof T;
  direction: 'asc' | 'desc';
};

----- src/common/helpers/domain/types/pagination.type.ts -----

export type PaginationType = {
  page: number;
  size?: number;
};

----- src/common/helpers/domain/types/paginated-resource.type.ts -----

export type PaginatedResourceType<T> = {
  items: T[];
  total: number;
  currentPage: number;
  lastPage: number;
  size: number;
};

----- src/common/helpers/domain/types/index.ts -----

export * from './filtering.type';
export * from './find-all-fields.dto';
export * from './find-one-by-fields.dto';
export * from './paginated-resource.type';
export * from './pagination.type';
export * from './prop-values.type';
export * from './response-format.type';
export * from './response.type';
export * from './sorting.type';

----- src/common/helpers/domain/types/find-all-fields.dto.ts -----

import { FilteringType } from './filtering.type';
import { PaginationType } from './pagination.type';
import { SortingType } from './sorting.type';

export type FindAllFieldsDto<T> = {
  pagination?: PaginationType;
  sort?: SortingType<T>;
  filters?: FilteringType<T>[];
  relations?: string[];
};

----- src/common/helpers/domain/types/filtering.type.ts -----

import { FilterRuleEnum } from '../enums';

export type FilteringType<T> = {
  property: keyof T;
  rule: FilterRuleEnum;
  value?: unknown;
};

----- src/common/helpers/domain/types/find-one-by-fields.dto.ts -----

import { FilteringType } from './filtering.type';

export type FindOneByFieldsDto<T> = {
  filter?: FilteringType<T>;
  relations?: string[];
};

----- src/common/helpers/domain/enums/filter-rule.enum.ts -----

export enum FilterRuleEnum {
  EQUALS = 'eq',
  NOT_EQUALS = 'neq',
  GREATER_THAN = 'gt',
  GREATER_THAN_OR_EQUALS = 'gte',
  LESS_THAN = 'lt',
  LESS_THAN_OR_EQUALS = 'lte',
  LIKE = 'like',
  NOT_LIKE = 'nlike',
  IN = 'in',
  NOT_IN = 'nin',
  IS_NULL = 'isnull',
  IS_NOT_NULL = 'isnotnull',
}

----- src/common/helpers/domain/enums/index.ts -----

export * from './filter-rule.enum';
export * from './general-statuses.enum';

----- src/common/helpers/domain/enums/general-statuses.enum.ts -----

export enum GeneralStatusesEnum {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
  DELETED = 'DELETED',
}

----- src/common/helpers/domain/index.ts -----

export * from './enums';
export * from './interfaces';
export * from './types';

----- src/common/helpers/domain/interfaces/index.ts -----

export * from './base-use-case.interface';
export * from './error.interface';

----- src/common/helpers/domain/interfaces/error.interface.ts -----

export interface ErrorInterface {
  message: string;
  codeError: string;
  serverMessage?: string;
}

----- src/common/helpers/domain/interfaces/base-use-case.interface.ts -----

export interface BaseUseCaseInterface<Fields, Entity> {
  run(fields: Fields, rqid: string): Promise<Entity>;
}

----- src/common/helpers/index.ts -----

export * from './application';
export * from './domain';
export * from './infrastructure';

----- src/common/helpers/application/paginated-resource.precenter.ts -----

import { PaginatedResourceType } from '../domain';

export class PaginatedResourcePresenter<T> {
  items: T[];
  total: number;
  current_page: number;
  last_page: number;
  size: number;

  constructor(paginatedResource: PaginatedResourceType<T>) {
    this.items = paginatedResource.items;
    this.total = paginatedResource.total;
    this.current_page = paginatedResource.currentPage;
    this.last_page = paginatedResource.lastPage;
    this.size = paginatedResource.size;
  }
}

----- src/common/helpers/application/paginated-resource.helper.ts -----

import { PaginatedResourceType } from '../domain';
import { PaginatedResourcePresenter } from './paginated-resource.precenter';
export const paginatedResourceHelper = <T, P>(
  paginatedResource: PaginatedResourceType<T>,
  Presenter: new (resource: T) => P,
): PaginatedResourcePresenter<P> => {
  return new PaginatedResourcePresenter<P>({
    ...paginatedResource,
    items: paginatedResource.items.map((resource) => new Presenter(resource)),
  });
};

----- src/common/helpers/application/general-policy.helper.ts -----

export const generalPolicyHelper = ({
  userPermissions,
  validPermissions,
}: {
  userPermissions: string[];
  validPermissions: string[];
}): boolean => {
  return validPermissions.some((permission) =>
    userPermissions.includes(permission),
  );
};

export class GeneralPolicy {
  constructor() {}

  hasPermission(
    userPermissions: string[],
    validPermissions: string[] | string,
  ): boolean {
    if (typeof validPermissions === 'string') {
      return userPermissions.includes(validPermissions);
    }

    return validPermissions.some((permission) =>
      userPermissions.includes(permission),
    );
  }
}

----- src/common/helpers/application/index.ts -----

export * from './general-policy.helper';
export * from './paginated-resource.helper';
export * from './paginated-resource.precenter';

----- src/common/index.ts -----

export * from './adapters';
export * from './helpers';

----- src/common/adapters/logger/infrastructure/logger.service.ts -----

import { Injectable, Logger } from '@nestjs/common';
import { LoggerServiceInterface, LoggerType } from '../domain';

@Injectable()
export class LoggerService extends Logger implements LoggerServiceInterface {
  debug({ message, context }: LoggerType) {
    if (process.env.NODE_ENV !== 'production') {
      super.debug(message, context);
    }
  }

  log({ message, context, requestId }: LoggerType) {
    message = typeof message === 'string' ? { message } : message;

    const log = JSON.stringify({
      context,
      requestId,
      ...message,
    });

    super.log(log, context);
  }

  error({ message, context }: LoggerType) {
    super.error(message, undefined, context);
  }

  warn({ message, context }: LoggerType) {
    super.warn(message, context);
  }

  verbose({ message, context }: LoggerType) {
    if (process.env.NODE_ENV !== 'production') {
      super.verbose(message, context);
    }
  }
}

----- src/common/adapters/logger/infrastructure/logger.module.ts -----

import { Module } from '@nestjs/common';
import { LoggerService } from './logger.service';
import { LoggerProvidersEnum } from '../domain';

@Module({
  providers: [
    {
      provide: LoggerProvidersEnum.LOGGER_SERVICE,
      useClass: LoggerService,
    },
  ],
  exports: [LoggerProvidersEnum.LOGGER_SERVICE],
})
export class LoggerModule {}

----- src/common/adapters/logger/infrastructure/index.ts -----

export * from './logger.module';
export * from './logger.service';

----- src/common/adapters/logger/domain/logger-providers.enum.ts -----

export enum LoggerProvidersEnum {
  LOGGER_SERVICE = 'LoggerService',
}

----- src/common/adapters/logger/domain/logger.type.ts -----

import { BaseCustomException } from '@common/adapters/exception/infrastructure';

export type LoggerType = {
  context: string;
  message: BaseCustomException | string | object;
  trace?: string | object;
  requestId?: string;
};

----- src/common/adapters/logger/domain/index.ts -----

export * from './logger-providers.enum';
export * from './logger-service.interface';
export * from './logger.type';

----- src/common/adapters/logger/domain/logger-service.interface.ts -----

import { LoggerType } from './logger.type';

export interface LoggerServiceInterface {
  debug(loggerDebug: LoggerType): void;
  log(loggerLog: LoggerType): void;
  error(loggerError: LoggerType): void;
  warn(loggerWarn: LoggerType): void;
  verbose(loggerVerbose: LoggerType): void;
}

----- src/common/adapters/logger/index.ts -----

export * from './domain';
export * from './infrastructure';

----- src/common/adapters/token/infrastructure/token-jwt.service.ts -----

import { Injectable } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { TokenPayloadType, TokenServiceInterface } from '../domain';

@Injectable()
export class TokenJwtService implements TokenServiceInterface {
  constructor(private readonly jwtService: JwtService) {}

  generateToken(payload: TokenPayloadType): {
    token: string;
    tokenExpiration: number;
  } {
    const token = this.jwtService.sign(payload);
    const expiration = this.jwtService.decode(token).exp;

    return { token, tokenExpiration: expiration * 1000 };
  }

  verifyToken(token: string): any {
    try {
      return this.jwtService.verify(token);
    } catch (e) {
      throw new Error('Invalid token');
    }
  }
}

----- src/common/adapters/token/infrastructure/strategies/jwt-passport.strategy.ts -----

import { Inject } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import {
  ConfigurationType,
  JwtConfigType,
} from '@common/adapters/configuration/domain';
import { UserProvidersEnum } from '@modules/users/domain';
import { FindByUserUseCase } from '@modules/users/application';
import {
  LoggerProvidersEnum,
  LoggerServiceInterface,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { TokenPayloadType } from '../../domain';
import { PermissionType } from '@modules/permissions/domain';
import { RoleType } from '@modules/roles/domain';
import { FilterRuleEnum } from '@common/helpers/domain';

export class JwtPassportStrategy extends PassportStrategy(Strategy, 'jwt') {
  private readonly context = JwtPassportStrategy.name;

  constructor(
    @Inject(ConfigService)
    private readonly configService: ConfigService<ConfigurationType>,
    @Inject(UserProvidersEnum.FIND_BY_USER_USE_CASE)
    private readonly findByUserUseCase: FindByUserUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      ignoreExpiration: false,
      secretOrKey: configService.get<JwtConfigType>('jwt').jwtSecret,
    });
  }

  async validate({ sub }: TokenPayloadType) {
    try {
      const { roles, permissions, ...userData } =
        await this.findByUserUseCase.run({
          filter: { property: 'id', rule: FilterRuleEnum.EQUALS, value: sub },
          relations: ['roles.permissions', 'permissions'],
        });

      if (!userData) {
        throw this.exception.UnauthorizedException({
          message: {
            codeError: 'TKN012',
            message: 'User not found',
          },
          context: this.context,
        });
      }

      if (userData.deletedAt) {
        throw this.exception.UnauthorizedException({
          message: {
            codeError: 'TKN013',
            message: 'User was deleted',
          },
          context: this.context,
        });
      }

      const userPermissions = this.getUniquePermissions(roles, permissions);

      return { data: userData, permissions: userPermissions };
    } catch (error) {
      throw error;
    }
  }

  private getUniquePermissions(
    roles: RoleType[],
    permissions: PermissionType[],
  ): string[] {
    const rolesPermissions = roles.reduce(
      (acc, role) => [...acc, ...role.permissions],
      [],
    );

    const mergedPermissions = [...permissions, ...rolesPermissions];

    const uniqueEntitiesMap = new Map<number, PermissionType>();

    mergedPermissions.forEach((entity) => {
      uniqueEntitiesMap.set(entity.id, entity);
    });

    return Array.from(uniqueEntitiesMap.values()).map(
      (permission) => permission.name,
    );
  }
}

----- src/common/adapters/token/infrastructure/strategies/index.ts -----

export * from './jwt-passport.strategy';

----- src/common/adapters/token/infrastructure/index.ts -----

export * from './jwt-config.service';
export * from './strategies';
export * from './token-jwt.service';
export * from './token.module';

----- src/common/adapters/token/infrastructure/jwt-config.service.ts -----

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { JwtModuleOptions, JwtOptionsFactory } from '@nestjs/jwt';
import {
  ConfigurationType,
  JwtConfigType,
} from '@common/adapters/configuration/domain';

@Injectable()
export class JwtConfigService implements JwtOptionsFactory {
  constructor(private configService: ConfigService<ConfigurationType>) {}

  createJwtOptions(): JwtModuleOptions | Promise<JwtModuleOptions> {
    const jwt = this.configService.get<JwtConfigType>('jwt');

    return {
      secret: jwt.jwtSecret,
      signOptions: {
        expiresIn: jwt.jwtExpirationTime,
      },
    };
  }
}

----- src/common/adapters/token/infrastructure/token.module.ts -----

import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import {
  ConfigurationModule,
  ConfigurationService,
} from '@common/adapters/configuration/infrastructure';
import { TokenProvidersEnum } from '../domain';
import { JwtConfigService } from './jwt-config.service';
import { TokenJwtService } from './token-jwt.service';
import { PassportModule } from '@nestjs/passport';
import { JwtPassportStrategy } from './strategies';
import { UserModule } from '@modules/users/infrastructure';
import { LoggerModule } from '@common/adapters/logger/infrastructure';
import { ExceptionModule } from '@common/adapters/exception/infrastructure';

@Module({
  imports: [
    PassportModule.register({
      defaultStrategy: 'jwt',
    }),
    JwtModule.registerAsync({
      imports: [ConfigurationModule],
      inject: [ConfigurationService],
      useClass: JwtConfigService,
    }),
    UserModule,
    LoggerModule,
    ExceptionModule,
  ],
  providers: [
    {
      provide: TokenProvidersEnum.TOKEN_SERVICE,
      useClass: TokenJwtService,
    },
    JwtPassportStrategy,
  ],
  exports: [TokenProvidersEnum.TOKEN_SERVICE],
})
export class TokenModule {}

----- src/common/adapters/token/domain/token-payload.type.ts -----

export class TokenPayloadType {
  sub: number | string;
}

----- src/common/adapters/token/domain/token-service.interface.ts -----

import { TokenPayloadType } from './token-payload.type';

export interface TokenServiceInterface {
  generateToken(payload: TokenPayloadType): {
    token: string;
    tokenExpiration: number;
  };
  verifyToken(token: string): any;
}

----- src/common/adapters/token/domain/token-providers.enum.ts -----

export enum TokenProvidersEnum {
  TOKEN_SERVICE = 'TokenService',
}

----- src/common/adapters/token/domain/index.ts -----

export * from './token-payload.type';
export * from './token-providers.enum';
export * from './token-service.interface';

----- src/common/adapters/token/index.ts -----

export * from './domain';
export * from './infrastructure';

----- src/common/adapters/exception/infrastructure/exception.module.ts -----

import { Module } from '@nestjs/common';
import { ExceptionService } from './exception.service';
import { ExceptionProvidersEnum } from '../domain';
import { APP_FILTER } from '@nestjs/core';
import {
  AllExceptionFilter,
  BaseCustomExceptionFilter,
  ValidationExceptionFilter,
} from './filters';
import { LoggerModule } from '@common/adapters/logger/infrastructure';

@Module({
  imports: [LoggerModule],
  providers: [
    {
      provide: APP_FILTER,
      useClass: AllExceptionFilter, // Se ejecuta al final (si ningún otro lo capturó)
    },
    {
      provide: APP_FILTER,
      useClass: ValidationExceptionFilter, // Más específico
    },
    {
      provide: APP_FILTER,
      useClass: BaseCustomExceptionFilter, // Más específico
    },
    {
      provide: ExceptionProvidersEnum.EXCEPTION_SERVICE,
      useClass: ExceptionService,
    },
  ],
  exports: [ExceptionProvidersEnum.EXCEPTION_SERVICE],
})
export class ExceptionModule {}

----- src/common/adapters/exception/infrastructure/exception.service.ts -----

import { HttpException, Injectable } from '@nestjs/common';
import {
  ExceptionServiceInterface,
  FormatExceptionMessageInterface,
} from '../domain';
import {
  BadRequestCustomException,
  ForbiddenCustomException,
  InternalServerErrorCustomException,
  UnauthorizedCustomException,
} from './custom-exceptions';

@Injectable()
export class ExceptionService implements ExceptionServiceInterface {
  badRequestException({
    message,
    context,
    error,
  }: FormatExceptionMessageInterface): Error {
    return (
      this.validateErrorType(error) ||
      new BadRequestCustomException(context, message)
    );
  }

  internalServerErrorException({
    message,
    context,
    error,
  }: FormatExceptionMessageInterface): Error {
    if (error instanceof AggregateError) {
      return new InternalServerErrorCustomException(
        context,
        message,
        error.errors.map((e) => e.message).join(', '), //TODO: pasar este trace al mensaje
      );
    }

    return (
      this.validateErrorType(error) ||
      new InternalServerErrorCustomException(context, message, error.message)
    );
  }

  forbiddenException({
    message,
    context,
    error,
  }: FormatExceptionMessageInterface): Error {
    return (
      this.validateErrorType(error) ||
      new ForbiddenCustomException(context, message)
    );
  }

  UnauthorizedException({
    message,
    context,
    error,
  }: FormatExceptionMessageInterface): Error {
    return (
      this.validateErrorType(error) ||
      new UnauthorizedCustomException(context, message)
    );
  }

  private validateErrorType(error: Error): Error {
    return error instanceof HttpException && error;
  }
}

----- src/common/adapters/exception/infrastructure/custom-exceptions/internal-server-error-custom.exception.ts -----

import { HttpStatus } from '@nestjs/common';
import { BaseCustomException } from './base-custom.exception';
import { InternalErrorMessageInterface } from '../../domain';

export class InternalServerErrorCustomException extends BaseCustomException {
  constructor(
    context: string,
    message: InternalErrorMessageInterface,
    stack: string,
  ) {
    super(context, message, HttpStatus.INTERNAL_SERVER_ERROR, stack);
  }
}

----- src/common/adapters/exception/infrastructure/custom-exceptions/base-custom.exception.ts -----

import { HttpException } from '@nestjs/common';
import { InternalErrorMessageInterface } from '../../domain';

export class BaseCustomException extends HttpException {
  context: string;
  stackString: string;

  constructor(
    context: string,
    message: InternalErrorMessageInterface,
    status: number,
    stackString?: string,
  ) {
    super(message, status);
    this.context = context;
    this.stackString = stackString;
  }
}

----- src/common/adapters/exception/infrastructure/custom-exceptions/bad-request-custom.exception.ts -----

import { HttpStatus } from '@nestjs/common';
import { BaseCustomException } from './base-custom.exception';
import { InternalErrorMessageInterface } from '../../domain';

export class BadRequestCustomException extends BaseCustomException {
  constructor(context: string, message: InternalErrorMessageInterface) {
    super(context, message, HttpStatus.BAD_REQUEST);
  }
}

----- src/common/adapters/exception/infrastructure/custom-exceptions/index.ts -----

export * from './bad-request-custom.exception';
export * from './base-custom.exception';
export * from './forbidden-custom.exception';
export * from './internal-server-error-custom.exception';
export * from './unauthorized-custom.exception';

----- src/common/adapters/exception/infrastructure/custom-exceptions/forbidden-custom.exception.ts -----

import { HttpStatus } from '@nestjs/common';
import { BaseCustomException } from './base-custom.exception';
import { InternalErrorMessageInterface } from '../../domain';

export class ForbiddenCustomException extends BaseCustomException {
  constructor(context: string, message: InternalErrorMessageInterface) {
    super(context, message, HttpStatus.FORBIDDEN);
  }
}

----- src/common/adapters/exception/infrastructure/custom-exceptions/unauthorized-custom.exception.ts -----

import { HttpStatus } from '@nestjs/common';
import { BaseCustomException } from './base-custom.exception';
import { InternalErrorMessageInterface } from '../../domain';

export class UnauthorizedCustomException extends BaseCustomException {
  constructor(context: string, message: InternalErrorMessageInterface) {
    super(context, message, HttpStatus.UNAUTHORIZED);
  }
}

----- src/common/adapters/exception/infrastructure/index.ts -----

export * from './custom-exceptions';
export * from './exception.module';
export * from './exception.service';
export * from './filters';

----- src/common/adapters/exception/infrastructure/filters/base-custom-exception.filter.ts -----

import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  Inject,
  Injectable,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { BaseCustomException } from '@common/adapters/exception/infrastructure';
import { LoggerService } from '@common/adapters/logger/infrastructure';
import { ErrorInterface } from '@common/helpers/domain';
import { LoggerProvidersEnum } from '@common/adapters/logger/domain';

@Injectable()
@Catch(BaseCustomException)
export class BaseCustomExceptionFilter implements ExceptionFilter {
  constructor(
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerService,
  ) {}

  catch(exception: BaseCustomException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const requestId = request.headers['x-request-id'] as string;

    const status = exception.getStatus();
    const message = exception.getResponse() as ErrorInterface;
    const context = exception.context;
    const stack = exception.stackString;

    const responseData = {
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      codeError: message.codeError,
      message: message.message,
    };

    const logMessage = {
      context,
      requestId,
      ...responseData,
      trace: stack,
    };

    this.logger.error({
      context,
      message: JSON.stringify(logMessage),
    });

    response.status(status).json(responseData);
  }
}

----- src/common/adapters/exception/infrastructure/filters/validation-exception.filter.ts -----

import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  BadRequestException,
  HttpStatus,
  Inject,
  Injectable,
} from '@nestjs/common';
import { Request, Response } from 'express';
import { LoggerService } from '@common/adapters/logger/infrastructure';
import { LoggerProvidersEnum } from '@common/adapters/logger/domain';

@Injectable()
@Catch(BadRequestException)
export class ValidationExceptionFilter implements ExceptionFilter {
  constructor(
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerService,
  ) {}

  catch(exception: BadRequestException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const requestId = request.headers['x-request-id'] as string;

    const exceptionResponse = exception.getResponse();
    let messages: string[] = [];

    if (
      typeof exceptionResponse === 'object' &&
      (exceptionResponse as any).message
    ) {
      messages = (exceptionResponse as any).message;
    } else if (Array.isArray(exceptionResponse)) {
      messages = exceptionResponse;
    }

    // Si se trata de errores de validación (array de mensajes), usamos 422
    let status = exception.getStatus();
    if (Array.isArray(messages)) {
      status = HttpStatus.UNPROCESSABLE_ENTITY;
    }

    // Agrupar errores por propiedad
    const groupedErrors: Record<string, string[]> = {};
    messages.forEach((message) => {
      let property = '';
      // Se asume que el nombre de la propiedad es la primera palabra del mensaje
      const firstWordMatch = message.match(/^(\w+)/);
      if (firstWordMatch) {
        property = firstWordMatch[1];
      }
      // Para mensajes que comienzan con "each", se extrae la propiedad después de "in"
      if (property === 'each') {
        const inMatch = message.match(/in (\w+)/);
        if (inMatch) {
          property = inMatch[1];
        }
      }
      if (!property) {
        property = 'unknown';
      }
      if (!groupedErrors[property]) {
        groupedErrors[property] = [];
      }
      groupedErrors[property].push(message);
    });

    const errorsArray = Object.entries(groupedErrors).map(([prop, errors]) => ({
      property: prop,
      errors,
    }));

    const context = `ValidationException for ${request.path}`;

    const logMessage = {
      context,
      requestId,
      errors: errorsArray,
    };

    this.logger.error({
      context,
      message: JSON.stringify(logMessage),
    });

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      errors: errorsArray,
    });
  }
}

----- src/common/adapters/exception/infrastructure/filters/all-exception.filter.ts -----

import { Request, Response } from 'express';
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpStatus,
  Inject,
  Injectable,
} from '@nestjs/common';
import { LoggerService } from '@common/adapters/logger/infrastructure';
import { LoggerProvidersEnum } from '@common/adapters/logger/domain';

@Injectable()
@Catch()
export class AllExceptionFilter implements ExceptionFilter {
  constructor(
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerService,
  ) {}

  catch(exception: Error, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const requestId = request.headers['x-request-id'] as string;

    const status = HttpStatus.INTERNAL_SERVER_ERROR;
    const message = exception.message;
    const context = `Unhandled Exception for ${request.path}`;

    const logMessage = {
      context,
      requestId,
      message,
    };

    this.logger.error({
      context,
      message: JSON.stringify(logMessage),
    });

    response.status(status).json({
      statusCode: status,
      timestamp: new Date().toISOString(),
      path: request.url,
      message,
    });
  }
}

----- src/common/adapters/exception/infrastructure/filters/index.ts -----

export * from './all-exception.filter';
export * from './base-custom-exception.filter';
export * from './validation-exception.filter';

----- src/common/adapters/exception/domain/internal-error-message.interface.ts -----

export interface InternalErrorMessageInterface {
  message: string | object;
  codeError: string;
}

----- src/common/adapters/exception/domain/format-exception-message.interface.ts -----

import { InternalErrorMessageInterface } from './internal-error-message.interface';

export interface FormatExceptionMessageInterface {
  message: InternalErrorMessageInterface;
  context: string;
  error?: Error;
}

----- src/common/adapters/exception/domain/exeption-service.interface.ts -----

import { FormatExceptionMessageInterface } from './format-exception-message.interface';

export interface ExceptionServiceInterface {
  badRequestException(data: FormatExceptionMessageInterface): void;
  internalServerErrorException(data: FormatExceptionMessageInterface): void;
  forbiddenException(data: FormatExceptionMessageInterface): void;
  UnauthorizedException(data: FormatExceptionMessageInterface): void;
}

----- src/common/adapters/exception/domain/index.ts -----

export * from './exception-providers.enum';
export * from './exeption-service.interface';
export * from './format-exception-message.interface';
export * from './internal-error-message.interface';

----- src/common/adapters/exception/domain/exception-providers.enum.ts -----

export enum ExceptionProvidersEnum {
  EXCEPTION_SERVICE = 'ExceptionService',
}

----- src/common/adapters/exception/index.ts -----

export * from './domain';
export * from './infrastructure';

----- src/common/adapters/hash/infrastructure/hash.module.ts -----

import { Module } from '@nestjs/common';
import { HashProvidersEnum } from '../domain';
import { HashBcryptService } from './hash-bcrypt.service';

@Module({
  providers: [
    {
      provide: HashProvidersEnum.HASH_SERVICE,
      useClass: HashBcryptService,
    },
  ],
  exports: [HashProvidersEnum.HASH_SERVICE],
})
export class HashModule {}

----- src/common/adapters/hash/infrastructure/index.ts -----

export * from './hash-bcrypt.service';
export * from './hash.module';

----- src/common/adapters/hash/infrastructure/hash-bcrypt.service.ts -----

import { Injectable } from '@nestjs/common';
import { hash, compare, genSalt } from 'bcrypt';
import { HashServiceInterface } from '../domain';

@Injectable()
export class HashBcryptService implements HashServiceInterface {
  async hash(hashString: string): Promise<string> {
    const salt = await genSalt();

    return await hash(hashString, salt);
  }

  async compare(password: string, hashPassword: string): Promise<boolean> {
    return await compare(password, hashPassword);
  }
}

----- src/common/adapters/hash/domain/index.ts -----

export * from './hash-providers.enum';
export * from './hash-service.interface';

----- src/common/adapters/hash/domain/hash-providers.enum.ts -----

export enum HashProvidersEnum {
  HASH_SERVICE = 'HashService',
}

----- src/common/adapters/hash/domain/hash-service.interface.ts -----

export interface HashServiceInterface {
  hash(hashString: string): Promise<string>;
  compare(password: string, hashPassword: string): Promise<boolean>;
}

----- src/common/adapters/hash/index.ts -----

export * from './domain';
export * from './infrastructure';

----- src/common/adapters/index.ts -----

export * from './configuration';
export * from './database';
export * from './exception';
export * from './hash';
export * from './logger';
export * from './token';

----- src/common/adapters/database/infrastructure/database.module.ts -----

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import {
  ConfigurationModule,
  ConfigurationService,
} from '@common/adapters/configuration/infrastructure';
import { TypeOrmConfigService } from './typeorm-config.service';

@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      imports: [ConfigurationModule],
      inject: [ConfigurationService],
      useClass: TypeOrmConfigService,
    }),
  ],
  exports: [TypeOrmModule],
})
export class DatabaseModule {}

----- src/common/adapters/database/infrastructure/typeorm-config.service.ts -----

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { TypeOrmModuleOptions, TypeOrmOptionsFactory } from '@nestjs/typeorm';
import {
  ConfigurationType,
  DataBaseConfigType,
  TypeOrmConfigType,
} from '@common/adapters/configuration/domain';
import { join } from 'path';

@Injectable()
export class TypeOrmConfigService implements TypeOrmOptionsFactory {
  constructor(private configService: ConfigService<ConfigurationType>) {}

  createTypeOrmOptions(): TypeOrmModuleOptions {
    const database = this.configService.get<DataBaseConfigType>('database');
    const typeOrm = this.configService.get<TypeOrmConfigType>('typeOrm');

    return {
      type: 'postgres',
      host: database.host,
      port: database.port,
      username: database.username,
      password: database.password,
      database: database.database,
      logging: typeOrm.logging,
      synchronize: typeOrm.synchronize,
      autoLoadEntities: true,
      entities: [
        join(
          __dirname,
          '..',
          '..',
          '..',
          '..',
          'modules',
          '**',
          '*.entity.{ts,js}',
        ),
      ],
    };
  }
}

----- src/common/adapters/database/infrastructure/index.ts -----

export * from './database.module';
export * from './typeorm-config.service';

----- src/common/adapters/database/index.ts -----

export * from './infrastructure';

----- src/common/adapters/configuration/infrastructure/configuration.module.ts -----

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { ConfigurationService } from './configuration.service';

@Module({
  imports: [
    ConfigModule.forRoot({
      load: [ConfigurationService.getInstance().getConfig],
      isGlobal: true,
    }),
  ],
  providers: [ConfigurationService],
})
export class ConfigurationModule {}

----- src/common/adapters/configuration/infrastructure/configuration.service.ts -----

import { ConfigurationType } from '../domain';
import { AppConfig, DataBaseConfig, TypeOrmConfig, JwtConfig } from './configs';

export class ConfigurationService {
  private static instance: ConfigurationService;

  static getInstance(): ConfigurationService {
    if (!ConfigurationService.instance) {
      ConfigurationService.instance = new ConfigurationService();
    }

    return ConfigurationService.instance;
  }

  getConfig(): ConfigurationType {
    return {
      app: AppConfig.getInstance().config,
      database: DataBaseConfig.getInstance().config,
      typeOrm: TypeOrmConfig.getInstance().config,
      jwt: JwtConfig.getInstance().config,
    };
  }
}

----- src/common/adapters/configuration/infrastructure/configs/jwt.config.ts -----

import { JwtConfigType } from '../../domain';

export class JwtConfig {
  private static instance: JwtConfig;
  private _config: JwtConfigType;

  private constructor() {
    this._config = {
      jwtSecret: process.env.JWT_SECRET,
      jwtExpirationTime: process.env.JWT_EXPIRATION_TIME ?? '1h',
    };
  }

  static getInstance(): JwtConfig {
    if (!JwtConfig.instance) {
      JwtConfig.instance = new JwtConfig();
    }
    return JwtConfig.instance;
  }

  get config(): JwtConfigType {
    return this._config;
  }
}

----- src/common/adapters/configuration/infrastructure/configs/type-orm.config.ts -----

import { TypeOrmConfigType } from '../../domain';

export class TypeOrmConfig {
  private static instance: TypeOrmConfig;
  private _config: TypeOrmConfigType;

  private constructor() {
    this._config = {
      logging: process.env.TYPEORM_LOGGING === 'true',
      synchronize: process.env.TYPEORM_SINC === 'true',
    };
  }

  static getInstance(): TypeOrmConfig {
    if (!TypeOrmConfig.instance) {
      TypeOrmConfig.instance = new TypeOrmConfig();
    }
    return TypeOrmConfig.instance;
  }

  get config(): TypeOrmConfigType {
    return this._config;
  }
}

----- src/common/adapters/configuration/infrastructure/configs/database.config.ts -----

import { DataBaseConfigType, DatabasesTypes } from '../../domain';

export class DataBaseConfig {
  private static instance: DataBaseConfig;
  private _config: DataBaseConfigType;

  private constructor() {
    this._config = {
      type: (process.env.DB_TYPE as DatabasesTypes) ?? 'sqlite',
      host: process.env.DB_HOST ?? 'localhost',
      port: parseInt(process.env.DB_PORT ?? '5432'),
      username: process.env.DB_USERNAME ?? 'postgres',
      password: process.env.DB_PASSWORD ?? 'password',
      database: process.env.DB_DATABASE ?? 'postgres',
    };
  }

  static getInstance(): DataBaseConfig {
    if (!DataBaseConfig.instance) {
      DataBaseConfig.instance = new DataBaseConfig();
    }
    return DataBaseConfig.instance;
  }

  get config(): DataBaseConfigType {
    return this._config;
  }
}

----- src/common/adapters/configuration/infrastructure/configs/app.config.ts -----

import { AppConfigType } from '../../domain';

export class AppConfig {
  private static instance: AppConfig;
  private _config: AppConfigType;

  private constructor() {
    this._config = {
      env: process.env.APP_ENV ?? 'local',
      port: parseInt(process.env.APP_PORT ?? '3000'),
      name: process.env.APP_NAME ?? 'App Name',
      debug: process.env.APP_DEBUG === 'true',
      url: this.setUrl(),
    };
  }

  static getInstance(): AppConfig {
    if (!AppConfig.instance) {
      AppConfig.instance = new AppConfig();
    }
    return AppConfig.instance;
  }

  get config(): AppConfigType {
    return this._config;
  }

  private setUrl(): string {
    const port = process.env.APP_PORT ?? '3000';

    return process.env.APP_URL
      ? `${process.env.APP_URL}:${port}`
      : `http://localhost:${port}`;
  }
}

----- src/common/adapters/configuration/infrastructure/configs/index.ts -----

export * from './app.config';
export * from './database.config';
export * from './jwt.config';
export * from './type-orm.config';

----- src/common/adapters/configuration/infrastructure/index.ts -----

export * from './configs';
export * from './configuration.module';
export * from './configuration.service';

----- src/common/adapters/configuration/domain/configuration.type.ts -----

import {
  AppConfigType,
  DataBaseConfigType,
  JwtConfigType,
  TypeOrmConfigType,
} from './configs';

export type ConfigurationType = {
  app: AppConfigType;
  database: DataBaseConfigType;
  typeOrm: TypeOrmConfigType;
  jwt: JwtConfigType;
};

----- src/common/adapters/configuration/domain/configs/database-config.type.ts -----

export type DataBaseConfigType = {
  type: DatabasesTypes;
  host: string;
  port: number;
  username: string;
  password: string;
  database: string;
};

export type DatabasesTypes = 'sqlite' | 'postgres';

----- src/common/adapters/configuration/domain/configs/app-config.type.ts -----

export type AppConfigType = {
  env: string;
  port: number;
  name: string;
  debug: boolean;
  url: string;
};

----- src/common/adapters/configuration/domain/configs/jwt-config.type.ts -----

export type JwtConfigType = {
  jwtSecret: string;
  jwtExpirationTime: string;
};

----- src/common/adapters/configuration/domain/configs/index.ts -----

export * from './app-config.type';
export * from './database-config.type';
export * from './jwt-config.type';
export * from './type-orm-config.type';

----- src/common/adapters/configuration/domain/configs/type-orm-config.type.ts -----

export type TypeOrmConfigType = {
  synchronize: boolean;
  logging: boolean;
};

----- src/common/adapters/configuration/domain/index.ts -----

export * from './configs';
export * from './configuration.type';

----- src/common/adapters/configuration/index.ts -----

export * from './domain';
export * from './infrastructure';

----- src/modules/roles/infrastructure/seeders/roles.seeder.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { PermissionType } from '@modules/permissions/domain';
import { RoleRepositoryInterface, RoleType } from '../../domain';

export class RolesSeeder {
  private readonly context = RolesSeeder.name;

  constructor(
    private readonly roleRepository: RoleRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
  ) {}

  async seed(permissions: PermissionType[]): Promise<RoleType[]> {
    const adminPermissions = [
      ...permissions.filter((permission) =>
        permission.module.includes('permissions'),
      ),
      ...permissions.filter((permission) =>
        permission.module.includes('roles'),
      ),
      ...permissions.filter((permission) =>
        permission.name.includes('any:user'),
      ),
      ...permissions.filter((permission) =>
        permission.module.includes('orders'),
      ),
    ];

    const sellerPermissions = [
      ...permissions.filter((permission) =>
        permission.name.includes('own:user'),
      ),
    ];

    const roles = await this.roleRepository.store([
      { name: 'admin', status: 'ACTIVE', permissions: adminPermissions },
      { name: 'seller', status: 'ACTIVE', permissions: sellerPermissions },
    ]);

    this.logger.debug({
      message: 'Development roles seeded',
      context: this.context,
    });

    return roles as RoleType[];
  }
}

----- src/modules/roles/infrastructure/seeders/index.ts -----

export * from './roles.seeder';

----- src/modules/roles/infrastructure/roles.module.ts -----

import { forwardRef, Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import {
  LoggerProvidersEnum,
  LoggerServiceInterface,
} from '@common/adapters/logger/domain';
import { LoggerModule } from '@common/adapters/logger/infrastructure';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { ExceptionModule } from '@common/adapters/exception/infrastructure';
import { PermissionProvidersEnum } from '@modules/permissions/domain';
import { PermissionModule } from '@modules/permissions/infrastructure';
import { FindAllPermissionsUseCase } from '@modules/permissions/application';
import { RoleProvidersEnum, RoleRepositoryInterface } from '../domain';
import {
  DeleteRoleUseCase,
  FindAllRolesUseCase,
  FindByRoleUseCase,
  StoreRoleUseCase,
  UpdateRoleUseCase,
} from '../application';
import {
  DeleteRoleController,
  FindAllRolesController,
  FindByRoleController,
  StoreRoleController,
  UpdateRoleController,
} from './api';
import { RoleEntity, RoleTypeOrmRepository } from './persistence';
import { RolesSeeder } from './seeders';

@Module({
  imports: [
    TypeOrmModule.forFeature([RoleEntity]),
    forwardRef(() => PermissionModule),
    LoggerModule,
    ExceptionModule,
  ],
  controllers: [
    FindAllRolesController,
    FindByRoleController,
    StoreRoleController,
    UpdateRoleController,
    DeleteRoleController,
  ],
  providers: [
    {
      provide: RoleProvidersEnum.ROLE_REPOSITORY,
      useClass: RoleTypeOrmRepository,
    },
    {
      provide: RoleProvidersEnum.ROLE_SEEDER,
      inject: [
        RoleProvidersEnum.ROLE_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
      ],
      useFactory: (
        roleRepositoy: RoleRepositoryInterface,
        loggerService: LoggerServiceInterface,
      ) => new RolesSeeder(roleRepositoy, loggerService),
    },
    {
      inject: [
        RoleProvidersEnum.ROLE_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: RoleProvidersEnum.FIND_ALL_ROLES_USE_CASE,
      useFactory: (
        roleRepositoy: RoleRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new FindAllRolesUseCase(roleRepositoy, loggerService, exceptionService),
    },
    {
      inject: [
        RoleProvidersEnum.ROLE_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: RoleProvidersEnum.FIND_BY_ROLE_USE_CASE,
      useFactory: (
        roleRepositoy: RoleRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new FindByRoleUseCase(roleRepositoy, loggerService, exceptionService),
    },
    {
      inject: [
        RoleProvidersEnum.ROLE_REPOSITORY,
        PermissionProvidersEnum.FIND_ALL_PERMISSIONS_USE_CASE,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: RoleProvidersEnum.STORE_ROLE_USE_CASE,
      useFactory: (
        roleRepositoy: RoleRepositoryInterface,
        findAllPermissionsUseCase: FindAllPermissionsUseCase,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new StoreRoleUseCase(
          roleRepositoy,
          findAllPermissionsUseCase,
          loggerService,
          exceptionService,
        ),
    },
    {
      inject: [
        RoleProvidersEnum.ROLE_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: RoleProvidersEnum.UPDATE_ROLE_USE_CASE,
      useFactory: (
        roleRepositoy: RoleRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new UpdateRoleUseCase(roleRepositoy, loggerService, exceptionService),
    },
    {
      inject: [
        RoleProvidersEnum.ROLE_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: RoleProvidersEnum.DELETE_ROLE_USE_CASE,
      useFactory: (
        roleRepositoy: RoleRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new DeleteRoleUseCase(roleRepositoy, loggerService, exceptionService),
    },
  ],
  exports: [
    RoleProvidersEnum.FIND_ALL_ROLES_USE_CASE,
    RoleProvidersEnum.FIND_BY_ROLE_USE_CASE,
    RoleProvidersEnum.STORE_ROLE_USE_CASE,
    RoleProvidersEnum.UPDATE_ROLE_USE_CASE,
    RoleProvidersEnum.DELETE_ROLE_USE_CASE,
  ],
})
export class RoleModule {}

----- src/modules/roles/infrastructure/dto/update-role.dto.ts -----

import {
  ArrayMinSize,
  IsArray,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';
import { UpdateRoleType } from '../../domain';

export class UpdateRoleDto implements UpdateRoleType {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsString()
  description: string;

  @IsOptional()
  @IsArray()
  @ArrayMinSize(1)
  @IsNumber({}, { each: true })
  permissionsIds: number[];
}

----- src/modules/roles/infrastructure/dto/create-role.dto.ts -----

import {
  ArrayMinSize,
  IsArray,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
} from 'class-validator';
import { CreateRoleType } from '../../domain';

export class CreateRoleDto implements CreateRoleType {
  @IsNotEmpty()
  @IsString()
  name: string;

  @IsOptional()
  @IsString()
  description: string;

  @IsNotEmpty()
  @IsArray()
  @ArrayMinSize(1)
  @IsNumber({}, { each: true })
  permissionsIds: number[];
}

----- src/modules/roles/infrastructure/dto/index.ts -----

export * from './create-role.dto';
export * from './update-role.dto';

----- src/modules/roles/infrastructure/persistence/role-typeorm.repository.ts -----

import { Inject } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import {
  getOrderTypeOrmHelper,
  getWhereTypeOrmHelper,
} from '@common/helpers/infrastructure';
import {
  FilterRuleEnum,
  FindAllFieldsDto,
  FindOneByFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import {
  LoggerProvidersEnum,
  LoggerServiceInterface,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import {
  RoleRepositoryInterface,
  RoleFilterType,
  roleErrorsCodes,
  CreateRoleType,
  UpdateRoleType,
} from '../../domain';
import { RoleEntity } from './role.entity';

export class RoleTypeOrmRepository
  implements RoleRepositoryInterface<RoleEntity>
{
  private readonly context = RoleTypeOrmRepository.name;

  constructor(
    @InjectRepository(RoleEntity)
    private readonly rolesRepository: Repository<RoleEntity>,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async findOneBy({
    filter,
    relations,
  }: FindOneByFieldsDto<RoleFilterType>): Promise<RoleEntity> {
    try {
      const where = getWhereTypeOrmHelper<RoleFilterType>(filter);

      const role = await this.rolesRepository.findOneOrFail({
        where,
        relations: relations || [],
      });

      return role;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL010,
        context: this.context,
        error,
      });
    }
  }

  async findAll({
    pagination,
    sort,
    filters,
    relations,
  }: FindAllFieldsDto<RoleFilterType> = {}): Promise<
    PaginatedResourceType<RoleEntity>
  > {
    try {
      const where = getWhereTypeOrmHelper<RoleFilterType>(filters);
      const order = getOrderTypeOrmHelper<RoleFilterType>(sort);

      const { page = 1, size } = pagination || {};

      const skip = size && (page - 1) * size;

      const [roles, count] = await this.rolesRepository.findAndCount({
        where,
        order,
        relations,
        skip,
        take: size,
      });

      const lastPage = size ? Math.ceil(count / size) : 1;

      return {
        total: count,
        currentPage: page,
        lastPage,
        size: size || count,
        items: roles,
      };
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL020,
        context: this.context,
        error,
      });
    }
  }

  async store(
    createRoleFields: CreateRoleType | CreateRoleType[],
  ): Promise<RoleEntity | RoleEntity[]> {
    try {
      if (Array.isArray(createRoleFields)) {
        return this.rolesRepository.save(createRoleFields);
      }

      return this.rolesRepository.save(createRoleFields);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL030,
        context: this.context,
        error,
      });
    }
  }

  async update(
    id: number,
    updateRoleFields: UpdateRoleType,
  ): Promise<RoleEntity> {
    try {
      const role = await this.findOneBy({
        filter: { property: 'id', rule: FilterRuleEnum.EQUALS, value: id },
      });

      return await this.rolesRepository.save({ ...role, ...updateRoleFields });
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL040,
        context: this.context,
        error,
      });
    }
  }

  async delete(id: number): Promise<RoleEntity> {
    try {
      const role = await this.findOneBy({
        filter: { property: 'id', rule: FilterRuleEnum.EQUALS, value: id },
      });

      return await this.rolesRepository.save({
        ...role,
        status: 'INACTIVE',
        deletedAt: new Date(),
      });
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL050,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/infrastructure/persistence/index.ts -----

export * from './role-typeorm.repository';
export * from './role.entity';

----- src/modules/roles/infrastructure/persistence/role.entity.ts -----

import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinTable,
  ManyToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { PermissionEntity } from '@modules/permissions/infrastructure';
import { UserEntity } from '@modules/users/infrastructure';
import { RoleType } from '../../domain';

@Entity({ name: 'roles' })
export class RoleEntity implements RoleType {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'varchar',
    length: 100,
    nullable: false,
  })
  name: string;

  @Column({
    type: 'varchar',
    nullable: false,
    default: true,
  })
  status: string;

  @CreateDateColumn({
    name: 'created_at',
    nullable: false,
  })
  createdAt: Date;

  @UpdateDateColumn({
    name: 'updated_at',
    nullable: false,
  })
  updatedAt: Date;

  @DeleteDateColumn({
    name: 'deleted_at',
    nullable: true,
  })
  deletedAt?: Date;

  @ManyToMany(() => PermissionEntity, (permission) => permission.roles)
  @JoinTable({
    name: 'permission_role',
    joinColumn: {
      name: 'role_id',
      referencedColumnName: 'id',
    },
    inverseJoinColumn: {
      name: 'permission_id',
      referencedColumnName: 'id',
    },
  })
  permissions: PermissionEntity[];

  @ManyToMany(() => UserEntity, (user) => user.roles)
  users: UserEntity[];
}

----- src/modules/roles/infrastructure/api/update-role.controller.ts -----

import {
  Body,
  Controller,
  Inject,
  Param,
  ParseIntPipe,
  Put,
} from '@nestjs/common';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  RolePermissionsEnum,
  RoleProvidersEnum,
  roleErrorsCodes,
} from '../../domain';
import { UpdateRoleUseCase } from '../../application';
import { UpdateRoleDto } from '../dto';
import { RolePresenter } from '../role.presenter';

@Controller()
export class UpdateRoleController {
  private readonly context = UpdateRoleController.name;

  constructor(
    @Inject(RoleProvidersEnum.UPDATE_ROLE_USE_CASE)
    private readonly updateRoleUseCase: UpdateRoleUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Put('api/roles/:id')
  @Auth<RolePermissionsEnum>(RolePermissionsEnum.UPDATE_ROLE)
  async run(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateRoleDto: UpdateRoleDto,
  ): Promise<RolePresenter> {
    try {
      const role = await this.updateRoleUseCase.run(id, updateRoleDto);

      return new RolePresenter(role);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL042,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/infrastructure/api/find-all-roles.controller.ts -----

import { Controller, Get, Inject } from '@nestjs/common';
import {
  FilteringType,
  PaginationType,
  SortingType,
  PaginatedResourceType,
} from '@common/helpers/domain';
import {
  PaginationParams,
  FilteringParams,
  SortingParams,
} from '@common/helpers/infrastructure';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  RoleFilterType,
  RolePermissionsEnum,
  RoleProvidersEnum,
  RoleType,
  roleErrorsCodes,
} from '../../domain';
import { FindAllRolesUseCase } from '../../application';
import { RolePresenter } from '../role.presenter';

@Controller()
export class FindAllRolesController {
  private readonly context = FindAllRolesController.name;

  constructor(
    @Inject(RoleProvidersEnum.FIND_ALL_ROLES_USE_CASE)
    private readonly findAllRolesUseCase: FindAllRolesUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Get('api/roles')
  @Auth<RolePermissionsEnum>(RolePermissionsEnum.LIST_ROLE)
  async run(
    @PaginationParams() paginationParams?: PaginationType,
    @SortingParams<RoleFilterType>('id', 'name', 'status')
    sortParams?: SortingType<RoleFilterType>,
    @FilteringParams<RoleFilterType>('id', 'name', 'status')
    filterParams?: FilteringType<RoleFilterType>[],
  ): Promise<PaginatedResourceType<Partial<RoleType>>> {
    try {
      const roles = await this.findAllRolesUseCase.run({
        pagination: paginationParams,
        sort: sortParams,
        filters: filterParams,
      });

      return {
        ...roles,
        items: roles.items.map((role) => new RolePresenter(role)),
      };
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL022,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/infrastructure/api/store-role.controller.ts -----

import { Body, Controller, Inject, Post } from '@nestjs/common';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  RolePermissionsEnum,
  RoleProvidersEnum,
  roleErrorsCodes,
} from '../../domain';
import { StoreRoleUseCase } from '../../application';
import { CreateRoleDto } from '../dto';
import { RolePresenter } from '../role.presenter';

@Controller()
export class StoreRoleController {
  private readonly context = StoreRoleController.name;

  constructor(
    @Inject(RoleProvidersEnum.STORE_ROLE_USE_CASE)
    private readonly storeRoleUseCase: StoreRoleUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Post('api/roles')
  @Auth<RolePermissionsEnum>(RolePermissionsEnum.CREATE_ROLE)
  async run(@Body() createRoleDto: CreateRoleDto): Promise<RolePresenter> {
    try {
      const role = await this.storeRoleUseCase.run(createRoleDto);

      return new RolePresenter(role);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL032,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/infrastructure/api/find-by-role.controller.ts -----

import { Controller, Get, Inject, Param, ParseIntPipe } from '@nestjs/common';
import { FilterRuleEnum } from '@common/helpers/domain';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  RolePermissionsEnum,
  RoleProvidersEnum,
  roleErrorsCodes,
} from '../../domain';
import { FindByRoleUseCase } from '../../application';
import { RolePresenter } from '../role.presenter';

@Controller()
export class FindByRoleController {
  private readonly context = FindByRoleController.name;

  constructor(
    @Inject(RoleProvidersEnum.FIND_BY_ROLE_USE_CASE)
    private readonly findByRoleUseCase: FindByRoleUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Get('api/roles/:id')
  @Auth<RolePermissionsEnum>(RolePermissionsEnum.READ_ROLE)
  async run(@Param('id', ParseIntPipe) id: number): Promise<RolePresenter> {
    try {
      const role = await this.findByRoleUseCase.run({
        filter: { property: 'id', rule: FilterRuleEnum.EQUALS, value: id },
      });

      return new RolePresenter(role);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL012,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/infrastructure/api/index.ts -----

export * from './delete-role.controller';
export * from './find-all-roles.controller';
export * from './find-by-role.controller';
export * from './store-role.controller';
export * from './update-role.controller';

----- src/modules/roles/infrastructure/api/delete-role.controller.ts -----

import {
  Controller,
  Delete,
  Inject,
  Param,
  ParseIntPipe,
} from '@nestjs/common';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  RolePermissionsEnum,
  RoleProvidersEnum,
  roleErrorsCodes,
} from '../../domain';
import { DeleteRoleUseCase } from '../../application';
import { RolePresenter } from '../role.presenter';

@Controller()
export class DeleteRoleController {
  private readonly context = DeleteRoleController.name;

  constructor(
    @Inject(RoleProvidersEnum.DELETE_ROLE_USE_CASE)
    private readonly deleteRoleUseCase: DeleteRoleUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Delete('api/roles/:id')
  @Auth<RolePermissionsEnum>(RolePermissionsEnum.DELETE_ROLE)
  async run(@Param('id', ParseIntPipe) id: number): Promise<RolePresenter> {
    try {
      const role = await this.deleteRoleUseCase.run(id);

      return new RolePresenter(role);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL052,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/infrastructure/role.presenter.ts -----

import { RoleType } from '../domain';

export class RolePresenter {
  id: number;
  name: string;
  status: string;
  description: string;
  created_at: Date;
  updated_at: Date;

  constructor(role: RoleType) {
    this.id = role.id;
    this.name = role.name;
    this.status = role.status;
    this.description = role.description;
    this.created_at = role.createdAt;
    this.updated_at = role.updatedAt;
  }
}

----- src/modules/roles/infrastructure/index.ts -----

export * from './api';
export * from './persistence';
export * from './role.presenter';
export * from './roles.module';
export * from './seeders';

----- src/modules/roles/domain/role.type.ts -----

import { PermissionType } from '@modules/permissions/domain';
import { UserType } from '@modules/users/domain';

export type RoleType = {
  id: number;
  name: string;
  description?: string;
  status: string;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date;
  permissions?: PermissionType[];
  users?: UserType[];
};

----- src/modules/roles/domain/role-errors.codes.ts -----

export const roleErrorsCodes = {
  ROL010: {
    codeError: 'ROL010',
    message: 'repo findOneBy',
  },
  ROL011: {
    codeError: 'ROL011',
    message: 'use case findOneBy',
  },
  ROL012: {
    codeError: 'ROL012',
    message: 'controller findOneBy',
  },
  ROL020: {
    codeError: 'ROL020',
    message: 'repo findAll',
  },
  ROL021: {
    codeError: 'ROL021',
    message: 'use case findAll',
  },
  ROL022: {
    codeError: 'ROL022',
    message: 'controller findAll',
  },
  ROL030: {
    codeError: 'ROL030',
    message: 'repo store',
  },
  ROL031: {
    codeError: 'ROL031',
    message: 'use case store',
  },
  ROL032: {
    codeError: 'ROL032',
    message: 'controller store',
  },
  ROL040: {
    codeError: 'ROL040',
    message: 'repo update',
  },
  ROL041: {
    codeError: 'ROL041',
    message: 'use case update',
  },
  ROL042: {
    codeError: 'ROL042',
    message: 'controller update',
  },
  ROL050: {
    codeError: 'ROL050',
    message: 'repo delete',
  },
  ROL051: {
    codeError: 'ROL051',
    message: 'use case delete',
  },
  ROL052: {
    codeError: 'ROL052',
    message: 'controller delete',
  },
};

----- src/modules/roles/domain/role-providers.enum.ts -----

export enum RoleProvidersEnum {
  ROLE_REPOSITORY = 'RoleRepository',
  FIND_ALL_ROLES_USE_CASE = 'FindAllRolesUseCase',
  FIND_BY_ROLE_USE_CASE = 'FindByRoleUseCase',
  STORE_ROLE_USE_CASE = 'StoreRoleUseCase',
  UPDATE_ROLE_USE_CASE = 'UpdateRoleUseCase',
  DELETE_ROLE_USE_CASE = 'DeleteRoleUseCase',
  ROLE_SEEDER = 'RoleSeeder',
}

----- src/modules/roles/domain/role-filter.type.ts -----

export type RoleFilterType = {
  id?: number;
  name?: string;
  status?: string;
};

----- src/modules/roles/domain/role-repository.interface.ts -----

import {
  FindAllFieldsDto,
  FindOneByFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import { RoleType } from './role.type';
import { RoleFilterType } from './role-filter.type';
import { CreateRoleType } from './create-role.type';
import { UpdateRoleType } from './update-role.type';

export interface RoleRepositoryInterface<Entity extends RoleType = RoleType> {
  findOneBy(
    findOneByFieldsDto: FindOneByFieldsDto<RoleFilterType>,
  ): Promise<Entity>;
  findAll(
    findAllFieldsDto: FindAllFieldsDto<RoleFilterType>,
  ): Promise<PaginatedResourceType<Entity>>;
  store(
    createRoleFields: CreateRoleType | CreateRoleType[],
  ): Promise<Entity | Entity[]>;
  update(id: number, updateRoleFields: UpdateRoleType): Promise<Entity>;
  delete(id: number): Promise<Entity>;
}

----- src/modules/roles/domain/role-permissions.enum.ts -----

export enum RolePermissionsEnum {
  CREATE_ROLE = 'create:role',
  READ_ROLE = 'read:role',
  LIST_ROLE = 'list:role',
  UPDATE_ROLE = 'update:role',
  DELETE_ROLE = 'delete:role',
}

----- src/modules/roles/domain/index.ts -----

export * from './create-role.type';
export * from './role-errors.codes';
export * from './role-filter.type';
export * from './role-permissions.enum';
export * from './role-providers.enum';
export * from './role-repository.interface';
export * from './role.type';
export * from './update-role.type';

----- src/modules/roles/domain/update-role.type.ts -----

export type UpdateRoleType = {
  name?: string;
  description?: string;
  status?: string;
};

----- src/modules/roles/domain/create-role.type.ts -----

import { RoleType } from './role.type';

export type CreateRoleType = Partial<RoleType> & {
  permissionsIds?: number[];
};

----- src/modules/roles/application/find-all-roles.use-case.ts -----

import {
  FindAllFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  RoleFilterType,
  RoleRepositoryInterface,
  RoleType,
  roleErrorsCodes,
} from '../domain';

export class FindAllRolesUseCase {
  private readonly context = FindAllRolesUseCase.name;

  constructor(
    private readonly roleRepository: RoleRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run({
    pagination,
    sort,
    filters,
  }: FindAllFieldsDto<RoleFilterType>): Promise<
    PaginatedResourceType<RoleType>
  > {
    try {
      const roleResource = await this.roleRepository.findAll({
        pagination,
        sort,
        filters,
      });

      return roleResource;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL021,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/application/store-role.use-case.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  CreateRoleType,
  RoleRepositoryInterface,
  RoleType,
  roleErrorsCodes,
} from '../domain';
import { FilterRuleEnum } from '@common/helpers/domain';
import { FindAllPermissionsUseCase } from '@modules/permissions/application';

export class StoreRoleUseCase {
  private readonly context = StoreRoleUseCase.name;

  constructor(
    private readonly roleRepository: RoleRepositoryInterface,
    private readonly findAllPermissionsUseCase: FindAllPermissionsUseCase,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run(createRole: CreateRoleType): Promise<RoleType> {
    try {
      const { permissionsIds, ...createRoleFields } = createRole;

      createRoleFields['permissions'] = await this.findAllPermissionsUseCase
        .run({
          pagination: { page: 1, size: 100 },
          filters: [
            {
              property: 'id',
              value: permissionsIds.join(','),
              rule: FilterRuleEnum.IN,
            },
          ],
        })
        .then((permissions) => permissions.items);

      const role = await this.roleRepository.store({
        ...createRoleFields,
        status: 'ACTIVE',
      });

      return role as RoleType;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL031,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/application/find-by-role.use-case.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  RoleFilterType,
  RoleRepositoryInterface,
  RoleType,
  roleErrorsCodes,
} from '../domain';
import { FindOneByFieldsDto } from '@common/helpers/domain';

export class FindByRoleUseCase {
  private readonly context = FindByRoleUseCase.name;

  constructor(
    private readonly roleRepository: RoleRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run({
    filter,
    relations,
  }: FindOneByFieldsDto<RoleFilterType>): Promise<RoleType> {
    try {
      const role = await this.roleRepository.findOneBy({
        filter,
        relations,
      });

      return role;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL011,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/application/index.ts -----

export * from './delete-role.use-case';
export * from './find-all-roles.use-case';
export * from './find-by-role.use-case';
export * from './store-role.use-case';
export * from './update-role.use-case';

----- src/modules/roles/application/delete-role.use-case.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import { RoleRepositoryInterface, RoleType, roleErrorsCodes } from '../domain';

export class DeleteRoleUseCase {
  private readonly context = DeleteRoleUseCase.name;

  constructor(
    private readonly roleRepository: RoleRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run(id: number): Promise<RoleType> {
    try {
      const role = await this.roleRepository.delete(id);

      return role;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL051,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/roles/application/update-role.use-case.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  UpdateRoleType,
  RoleRepositoryInterface,
  RoleType,
  roleErrorsCodes,
} from '../domain';

export class UpdateRoleUseCase {
  private readonly context = UpdateRoleUseCase.name;

  constructor(
    private readonly roleRepository: RoleRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run(id: number, updateRoleFields: UpdateRoleType): Promise<RoleType> {
    try {
      const role = await this.roleRepository.update(id, updateRoleFields);

      return role;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: roleErrorsCodes.ROL041,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/infrastructure/seeders/prod-users.seeder.ts -----

import { HashServiceInterface } from '@common/adapters/hash/domain';
import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import {
  CreateUserRepositoryType,
  UserRepositoryInterface,
  UserType,
} from '../../domain';
import { RoleType } from '@modules/roles/domain';

export class ProdUsersSeeder {
  private readonly context = ProdUsersSeeder.name;

  constructor(
    private readonly userRepository: UserRepositoryInterface,
    private readonly hashService: HashServiceInterface,
    private readonly logger: LoggerServiceInterface,
  ) {}

  async seed(roles: RoleType[]): Promise<UserType[]> {
    const password = await this.hashService.hash('password');
    const usersFields: CreateUserRepositoryType[] = [
      {
        name: 'Admin User',
        username: 'admin',
        email: 'admin@admin.com',
        password: password,
        status: 'ACTIVE',
        roles: roles.filter((role) => role.name === 'admin'),
      },
    ];

    const users = await this.userRepository.store(usersFields);

    this.logger.debug({
      message: 'Production users seeded',
      context: this.context,
    });

    return users as UserType[];
  }
}

----- src/modules/users/infrastructure/seeders/dev-users.seeder.ts -----

import { faker } from '@faker-js/faker';
import { HashServiceInterface } from '@common/adapters/hash/domain';
import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import {
  CreateUserRepositoryType,
  UserRepositoryInterface,
  UserType,
} from '../../domain';
import { RoleType } from '@modules/roles/domain';
import { FilterRuleEnum } from '@common/helpers/domain';

export class DevUsersSeeder {
  private readonly context = DevUsersSeeder.name;

  constructor(
    private readonly userRepository: UserRepositoryInterface,
    private readonly hashService: HashServiceInterface,
    private readonly logger: LoggerServiceInterface,
  ) {}

  async seed(roles: RoleType[]): Promise<UserType[]> {
    const usersFields: CreateUserRepositoryType[] = [];
    const password = await this.hashService.hash('password');

    usersFields.push({
      name: 'Admin User',
      username: 'admin',
      email: 'admin@admin.com',
      password: password,
      status: 'ACTIVE',
      roles: roles.filter((role) => role.name === 'admin'),
    });

    for (let i = 0; i < 10; i++) {
      const personInfo = faker.person;
      const internetInfo = faker.internet;

      usersFields.push({
        name: personInfo.fullName(),
        username: internetInfo.userName(),
        email: internetInfo.email(),
        password: password,
        status: 'ACTIVE',
        roles: [faker.helpers.arrayElement(roles)],
      });
    }

    const usersIds = await this.userRepository
      .store(usersFields)
      .then((users: UserType[]) => users.map((user) => user.id));

    const users = await this.userRepository
      .findAll({
        pagination: { page: 1, size: 100 },
        filters: [
          {
            property: 'id',
            rule: FilterRuleEnum.IN,
            value: usersIds.join(','),
          },
        ],
        relations: ['roles'],
      })
      .then((users) => users.items);

    this.logger.debug({
      message: 'Development users seeded',
      context: this.context,
    });

    return users as UserType[];
  }
}

----- src/modules/users/infrastructure/seeders/index.ts -----

export * from './dev-users.seeder';
export * from './prod-users.seeder';

----- src/modules/users/infrastructure/users.module.ts -----

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import {
  HashProvidersEnum,
  HashServiceInterface,
} from '@common/adapters/hash/domain';
import { HashModule } from '@common/adapters/hash/infrastructure';
import {
  LoggerProvidersEnum,
  LoggerServiceInterface,
} from '@common/adapters/logger/domain';
import { LoggerModule } from '@common/adapters/logger/infrastructure';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { ExceptionModule } from '@common/adapters/exception/infrastructure';
import { UserProvidersEnum, UserRepositoryInterface } from '../domain';
import {
  DeleteUserUseCase,
  FindAllUsersUseCase,
  FindByUserUseCase,
  StoreUserUseCase,
  UpdateUserUseCase,
  UserPolicy,
} from '../application';
import { UserEntity, UserTypeOrmRepository } from './persistence';
import {
  DeleteUserController,
  FindAllUsersController,
  FindByUserController,
  StoreUserController,
  UpdateUserController,
} from './api';
import { DevUsersSeeder, ProdUsersSeeder } from './seeders';
import { ConfigurationModule } from '@common/adapters/configuration/infrastructure';
import {
  AppConfigType,
  ConfigurationType,
} from '@common/adapters/configuration/domain';
import { ConfigService } from '@nestjs/config';
import { PermissionModule } from '@modules/permissions/infrastructure';
import { RoleModule } from '@modules/roles/infrastructure';
import { FindAllRolesUseCase } from '@modules/roles/application';
import { FindAllPermissionsUseCase } from '@modules/permissions/application';
import { RoleProvidersEnum } from '@modules/roles/domain';
import { PermissionProvidersEnum } from '@modules/permissions/domain';

@Module({
  imports: [
    TypeOrmModule.forFeature([UserEntity]),
    LoggerModule,
    ExceptionModule,
    HashModule,
    ConfigurationModule,
    PermissionModule,
    RoleModule,
  ],
  controllers: [
    FindAllUsersController,
    FindByUserController,
    StoreUserController,
    UpdateUserController,
    DeleteUserController,
  ],
  providers: [
    {
      provide: UserProvidersEnum.USER_REPOSITORY,
      useClass: UserTypeOrmRepository,
    },
    UserPolicy,
    {
      provide: UserProvidersEnum.USER_SEEDER,
      inject: [
        ConfigService,
        UserProvidersEnum.USER_REPOSITORY,
        HashProvidersEnum.HASH_SERVICE,
        LoggerProvidersEnum.LOGGER_SERVICE,
      ],
      useFactory: (
        configService: ConfigService<ConfigurationType>,
        userRepository: UserRepositoryInterface,
        hashService: HashServiceInterface,
        loggerService: LoggerServiceInterface,
      ) => {
        const env = configService.get<AppConfigType>('app').env;

        return env !== 'prod'
          ? new DevUsersSeeder(userRepository, hashService, loggerService)
          : new ProdUsersSeeder(userRepository, hashService, loggerService);
      },
    },
    {
      inject: [
        UserProvidersEnum.USER_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: UserProvidersEnum.FIND_ALL_USERS_USE_CASE,
      useFactory: (
        userRepository: UserRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new FindAllUsersUseCase(
          userRepository,
          loggerService,
          exceptionService,
        ),
    },
    {
      inject: [
        UserProvidersEnum.USER_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: UserProvidersEnum.FIND_BY_USER_USE_CASE,
      useFactory: (
        userRepository: UserRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new FindByUserUseCase(userRepository, loggerService, exceptionService),
    },
    {
      inject: [
        UserProvidersEnum.USER_REPOSITORY,
        RoleProvidersEnum.FIND_ALL_ROLES_USE_CASE,
        PermissionProvidersEnum.FIND_ALL_PERMISSIONS_USE_CASE,
        HashProvidersEnum.HASH_SERVICE,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: UserProvidersEnum.STORE_USER_USE_CASE,
      useFactory: (
        userRepository: UserRepositoryInterface,
        findAllRolesUseCase: FindAllRolesUseCase,
        findAllPermissionsUseCase: FindAllPermissionsUseCase,
        hashService: HashServiceInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new StoreUserUseCase(
          userRepository,
          findAllRolesUseCase,
          findAllPermissionsUseCase,
          hashService,
          loggerService,
          exceptionService,
        ),
    },
    {
      inject: [
        UserProvidersEnum.USER_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: UserProvidersEnum.UPDATE_USER_USE_CASE,
      useFactory: (
        userRepository: UserRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new UpdateUserUseCase(userRepository, loggerService, exceptionService),
    },
    {
      inject: [
        UserProvidersEnum.USER_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: UserProvidersEnum.DELETE_USER_USE_CASE,
      useFactory: (
        userRepository: UserRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new DeleteUserUseCase(userRepository, loggerService, exceptionService),
    },
  ],
  exports: [
    UserProvidersEnum.FIND_ALL_USERS_USE_CASE,
    UserProvidersEnum.FIND_BY_USER_USE_CASE,
    UserProvidersEnum.STORE_USER_USE_CASE,
    UserProvidersEnum.UPDATE_USER_USE_CASE,
    UserProvidersEnum.DELETE_USER_USE_CASE,
  ],
})
export class UserModule {}

----- src/modules/users/infrastructure/dto/create-user.dto.ts -----

import {
  ArrayMinSize,
  IsArray,
  IsEmail,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  MinLength,
  ValidateIf,
} from 'class-validator';
import { CreateUserType } from '../../domain';

export class CreateUserDto implements CreateUserType {
  @IsNotEmpty()
  @IsString()
  name: string;

  @IsNotEmpty()
  @IsString()
  username: string;

  @IsOptional()
  @IsEmail()
  email: string;

  @IsNotEmpty()
  @IsString()
  @MinLength(6)
  password: string;

  @ValidateIf((o) => !o.permissionsIds || o.permissionsIds.length === 0)
  @IsNotEmpty()
  @IsArray()
  @ArrayMinSize(1)
  @IsNumber({}, { each: true })
  rolesIds: number[];

  @ValidateIf((o) => !o.rolesIds || o.rolesIds.length === 0)
  @IsNotEmpty()
  @IsArray()
  @ArrayMinSize(1)
  @IsNumber({}, { each: true })
  permissionsIds: number[];
}

----- src/modules/users/infrastructure/dto/index.ts -----

export * from './create-user.dto';
export * from './update-user.dto';

----- src/modules/users/infrastructure/dto/update-user.dto.ts -----

import { IsEmail, IsOptional, IsString, MinLength } from 'class-validator';
import { UpdateUserType } from '../../domain';

export class UpdateUserDto implements UpdateUserType {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsEmail()
  email?: string;

  @IsOptional()
  @IsString()
  @MinLength(6)
  password?: string;
}

----- src/modules/users/infrastructure/user.presenter.ts -----

import { RolePresenter } from '@modules/roles/infrastructure';
import { UserType } from '../domain';

export class UserPresenter {
  id: number;
  name: string;
  email: string;
  username: string;
  created_at: Date;
  updated_at: Date;
  roles?: RolePresenter[];

  constructor(user: Omit<UserType, 'password'>) {
    this.id = user.id;
    this.name = user.name;
    this.username = user.username;
    this.email = user.email;
    this.created_at = user.createdAt;
    this.updated_at = user.updatedAt;
    user.roles &&
      (this.roles = user.roles.map((role) => new RolePresenter(role)));
  }
}

----- src/modules/users/infrastructure/persistence/user-typeorm.repository.ts -----

import { Inject } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import {
  getOrderTypeOrmHelper,
  getWhereTypeOrmHelper,
} from '@common/helpers/infrastructure';
import {
  FilterRuleEnum,
  FindAllFieldsDto,
  FindOneByFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import {
  LoggerProvidersEnum,
  LoggerServiceInterface,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import {
  UserRepositoryInterface,
  UserFilterType,
  // UpdateUserType,
  userErrorsCodes,
  UpdateUserType,
  CreateUserRepositoryType,
} from '../../domain';
import { UserEntity } from './user.entity';

export class UserTypeOrmRepository
  implements UserRepositoryInterface<UserEntity>
{
  private readonly context = UserTypeOrmRepository.name;

  constructor(
    @InjectRepository(UserEntity)
    readonly usersRepository: Repository<UserEntity>,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    readonly exception: ExceptionServiceInterface,
  ) {}

  async findOneBy({
    filter,
    relations,
  }: FindOneByFieldsDto<UserFilterType>): Promise<UserEntity> {
    try {
      const where = getWhereTypeOrmHelper<UserFilterType>(filter);

      const user = await this.usersRepository.findOne({
        where,
        relations: relations || [],
      });

      return user;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM010,
        context: this.context,
        error,
      });
    }
  }

  async findAll({
    pagination,
    sort,
    filters,
    relations,
  }: FindAllFieldsDto<UserFilterType> = {}): Promise<
    PaginatedResourceType<UserEntity>
  > {
    try {
      const where = getWhereTypeOrmHelper<UserFilterType>(filters);
      const order = getOrderTypeOrmHelper<UserFilterType>(sort);

      const { page = 1, size } = pagination || {};

      const skip = size && (page - 1) * size;

      const [users, count] = await this.usersRepository.findAndCount({
        where,
        order,
        relations,
        skip,
        take: size,
      });

      const lastPage = size ? Math.ceil(count / size) : 1;

      return {
        total: count,
        currentPage: page,
        lastPage,
        size: size || count,
        items: users,
      };
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM020,
        context: this.context,
        error,
      });
    }
  }

  async store(
    createUserFields: CreateUserRepositoryType | CreateUserRepositoryType[],
  ): Promise<UserEntity | UserEntity[]> {
    try {
      if (Array.isArray(createUserFields)) {
        return await this.usersRepository.save(createUserFields);
      }

      return await this.usersRepository.save(createUserFields);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM030,
        context: this.context,
        error,
      });
    }
  }

  async update(
    id: number,
    updateUserFields: UpdateUserType,
  ): Promise<UserEntity> {
    try {
      const user = await this.findOneBy({
        filter: { property: 'id', rule: FilterRuleEnum.EQUALS, value: id },
      });

      return await this.usersRepository.save({ ...user, ...updateUserFields });
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM040,
        context: this.context,
        error,
      });
    }
  }

  async delete(id: number): Promise<UserEntity> {
    try {
      const user = await this.findOneBy({
        filter: { property: 'id', rule: FilterRuleEnum.EQUALS, value: id },
      });

      await this.usersRepository.softRemove(user);

      return { ...user, id };
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM050,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/infrastructure/persistence/index.ts -----

export * from './user-typeorm.repository';
export * from './user.entity';

----- src/modules/users/infrastructure/persistence/user.entity.ts -----

import {
  Column,
  CreateDateColumn,
  DeleteDateColumn,
  Entity,
  JoinTable,
  ManyToMany,
  PrimaryGeneratedColumn,
  UpdateDateColumn,
} from 'typeorm';
import { PermissionEntity } from '@modules/permissions/infrastructure';
import { RoleEntity } from '@modules/roles/infrastructure';
import { UserType } from '../../domain';

@Entity({ name: 'users' })
export class UserEntity implements UserType {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'varchar',
    length: 50,
    nullable: false,
  })
  name: string;

  @Column({
    type: 'varchar',
    length: 50,
    nullable: false,
    unique: true,
  })
  username: string;

  @Column({
    type: 'varchar',
    length: 100,
    nullable: true,
  })
  email?: string;

  @Column({
    type: 'varchar',
    length: 128,
    nullable: false,
  })
  password: string;

  @Column({
    type: 'varchar',
    nullable: false,
    default: true,
  })
  status: string;

  @CreateDateColumn({
    name: 'created_at',
    nullable: false,
  })
  createdAt: Date;

  @UpdateDateColumn({
    name: 'updated_at',
    nullable: false,
  })
  updatedAt: Date;

  @DeleteDateColumn({
    name: 'deleted_at',
    nullable: true,
  })
  deletedAt?: Date;

  @ManyToMany(() => RoleEntity, (role) => role.users)
  @JoinTable({
    name: 'role_user',
    joinColumn: {
      name: 'user_id',
      referencedColumnName: 'id',
    },
    inverseJoinColumn: {
      name: 'role_id',
      referencedColumnName: 'id',
    },
  })
  roles?: RoleEntity[];

  @ManyToMany(() => PermissionEntity, (permission) => permission.users)
  @JoinTable({
    name: 'permission_user',
    joinColumn: {
      name: 'user_id',
      referencedColumnName: 'id',
    },
    inverseJoinColumn: {
      name: 'permission_id',
      referencedColumnName: 'id',
    },
  })
  permissions?: PermissionEntity[];
}

----- src/modules/users/infrastructure/api/store-user.controller.ts -----

import { Body, Controller, Inject, Post } from '@nestjs/common';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  UserPermissionsEnum,
  UserProvidersEnum,
  userErrorsCodes,
} from '../../domain';
import { StoreUserUseCase } from '../../application';
import { CreateUserDto } from '../dto';
import { UserPresenter } from '../user.presenter';

@Controller()
export class StoreUserController {
  private readonly context = StoreUserController.name;

  constructor(
    @Inject(UserProvidersEnum.STORE_USER_USE_CASE)
    private readonly storeUserUseCase: StoreUserUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Post('api/users')
  @Auth<UserPermissionsEnum>(UserPermissionsEnum.CREATE_ANY_USER)
  async run(@Body() createUserDto: CreateUserDto): Promise<UserPresenter> {
    try {
      const user = await this.storeUserUseCase.run(createUserDto);

      return new UserPresenter(user);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM032,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/infrastructure/api/update-user.controller.ts -----

import {
  Body,
  Controller,
  Inject,
  Param,
  ParseIntPipe,
  Put,
} from '@nestjs/common';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  UserPermissionsEnum,
  UserProvidersEnum,
  userErrorsCodes,
} from '../../domain';
import { UpdateUserUseCase } from '../../application';
import { UpdateUserDto } from '../dto';
import { UserPresenter } from '../user.presenter';

@Controller()
export class UpdateUserController {
  private readonly context = UpdateUserController.name;

  constructor(
    @Inject(UserProvidersEnum.UPDATE_USER_USE_CASE)
    private readonly updateUserUseCase: UpdateUserUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Put('api/users/:id')
  @Auth<UserPermissionsEnum>(UserPermissionsEnum.UPDATE_ANY_USER)
  async run(
    @Param('id', ParseIntPipe) id: number,
    @Body() updateUserDto: UpdateUserDto,
  ): Promise<UserPresenter> {
    try {
      const user = await this.updateUserUseCase.run(id, updateUserDto);

      return new UserPresenter(user);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM042,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/infrastructure/api/find-by-user.controller.ts -----

import { Controller, Get, Inject, Param, ParseIntPipe } from '@nestjs/common';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  UserPermissionsEnum,
  UserProvidersEnum,
  userErrorsCodes,
} from '../../domain';
import { FindByUserUseCase } from '../../application';
import { UserPresenter } from '../user.presenter';
import { FilterRuleEnum } from '@common/helpers/domain';

@Controller()
export class FindByUserController {
  private readonly context = FindByUserController.name;

  constructor(
    @Inject(UserProvidersEnum.FIND_BY_USER_USE_CASE)
    private readonly findByUserUseCase: FindByUserUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Get('api/users/:id')
  @Auth<UserPermissionsEnum>(UserPermissionsEnum.READ_ANY_USER)
  async run(@Param('id', ParseIntPipe) id: number): Promise<UserPresenter> {
    try {
      const user = await this.findByUserUseCase.run({
        filter: { property: 'id', rule: FilterRuleEnum.EQUALS, value: id },
      });

      return new UserPresenter(user);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM012,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/infrastructure/api/find-all-users.controller.ts -----

import { Controller, Get, Inject } from '@nestjs/common';
import {
  FilteringType,
  PaginationType,
  SortingType,
} from '@common/helpers/domain';
import {
  PaginationParams,
  FilteringParams,
  SortingParams,
} from '@common/helpers/infrastructure';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  UserFilterType,
  UserPermissionsEnum,
  UserProvidersEnum,
  UserType,
  userErrorsCodes,
} from '../../domain';
import { FindAllUsersUseCase } from '../../application';
import { UserPresenter } from '../user.presenter';
import {
  paginatedResourceHelper,
  PaginatedResourcePresenter,
} from '@common/helpers/application';

@Controller()
export class FindAllUsersController {
  private readonly context = FindAllUsersController.name;

  constructor(
    @Inject(UserProvidersEnum.FIND_ALL_USERS_USE_CASE)
    private readonly findAllUsersUseCase: FindAllUsersUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Get('api/users')
  @Auth<UserPermissionsEnum>(UserPermissionsEnum.LIST_ANY_USER)
  async run(
    @PaginationParams() paginationParams?: PaginationType,
    @SortingParams<UserFilterType>('id', 'email', 'name', 'username')
    sortParams?: SortingType<UserFilterType>,
    @FilteringParams<UserFilterType>('id', 'email', 'name', 'username')
    filterParams?: FilteringType<UserFilterType>[],
  ): Promise<PaginatedResourcePresenter<UserPresenter>> {
    try {
      const users = await this.findAllUsersUseCase.run({
        pagination: paginationParams,
        sort: sortParams,
        filters: filterParams,
      });

      return paginatedResourceHelper<UserType, UserPresenter>(
        users,
        UserPresenter,
      );
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM022,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/infrastructure/api/index.ts -----

export * from './delete-user.controller';
export * from './find-all-users.controller';
export * from './find-by-user.controller';
export * from './store-user.controller';
export * from './update-user.controller';

----- src/modules/users/infrastructure/api/delete-user.controller.ts -----

import {
  Controller,
  Delete,
  Inject,
  Param,
  ParseIntPipe,
} from '@nestjs/common';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  UserPermissionsEnum,
  UserProvidersEnum,
  userErrorsCodes,
} from '../../domain';
import { DeleteUserUseCase } from '../../application';
import { UserPresenter } from '../user.presenter';

@Controller()
export class DeleteUserController {
  private readonly context = DeleteUserController.name;

  constructor(
    @Inject(UserProvidersEnum.DELETE_USER_USE_CASE)
    private readonly deleteUserUseCase: DeleteUserUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Delete('api/users/:id')
  @Auth<UserPermissionsEnum>(UserPermissionsEnum.DELETE_ANY_USER)
  async run(@Param('id', ParseIntPipe) id: number): Promise<UserPresenter> {
    try {
      const user = await this.deleteUserUseCase.run(id);

      return new UserPresenter(user);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM052,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/infrastructure/index.ts -----

export * from './api';
export * from './dto';
export * from './persistence';
export * from './seeders';
export * from './user.presenter';
export * from './users.module';

----- src/modules/users/domain/user-providers.enum.ts -----

export enum UserProvidersEnum {
  USER_REPOSITORY = 'UserRepository',
  USER_SEEDER = 'UserSeeder',
  FIND_ALL_USERS_USE_CASE = 'FindAllUsersUseCase',
  FIND_BY_USER_USE_CASE = 'FindByUserUseCase',
  STORE_USER_USE_CASE = 'StoreUserUseCase',
  UPDATE_USER_USE_CASE = 'UpdateUserUseCase',
  DELETE_USER_USE_CASE = 'DeleteUserUseCase',
}

----- src/modules/users/domain/create-user.type.ts -----

import { CreateUserRepositoryType } from './create-user-repository.type';

export type CreateUserType = Omit<
  CreateUserRepositoryType,
  'status' | 'roles' | 'permissions'
> & {
  rolesIds?: number[];
  permissionsIds?: number[];
};

----- src/modules/users/domain/update-user.type.ts -----

export type UpdateUserType = {
  name?: string;
  email?: string;
  password?: string;
};

----- src/modules/users/domain/user-errors.codes.ts -----

export const userErrorsCodes = {
  UM010: {
    codeError: 'UM010',
    message: 'repo findOneBy',
  },
  UM011: {
    codeError: 'UM011',
    message: 'use case findOneBy',
  },
  UM012: {
    codeError: 'UM012',
    message: 'controller findOneBy',
  },
  UM020: {
    codeError: 'UM020',
    message: 'repo findAll',
  },
  UM021: {
    codeError: 'UM021',
    message: 'use case findAll',
  },
  UM022: {
    codeError: 'UM022',
    message: 'controller findAll',
  },
  UM030: {
    codeError: 'UM030',
    message: 'repo store',
  },
  UM031: {
    codeError: 'UM031',
    message: 'use case store',
  },
  UM032: {
    codeError: 'UM032',
    message: 'controller store',
  },
  UM040: {
    codeError: 'UM040',
    message: 'repo update',
  },
  UM041: {
    codeError: 'UM041',
    message: 'use case update',
  },
  UM042: {
    codeError: 'UM042',
    message: 'controller update',
  },
  UM050: {
    codeError: 'UM050',
    message: 'repo delete',
  },
  UM051: {
    codeError: 'UM051',
    message: 'use case delete',
  },
  UM052: {
    codeError: 'UM052',
    message: 'controller delete',
  },
};

----- src/modules/users/domain/user-permissions.enum.ts -----

export enum UserPermissionsEnum {
  CREATE_ANY_USER = 'create:any:user',
  READ_ANY_USER = 'read:any:user',
  LIST_ANY_USER = 'list:any:user',
  UPDATE_ANY_USER = 'update:any:user',
  UPDATE_OWN_USER = 'update:own:user',
  UPDATE_ANY_USER_PASSWORD = 'update:any:user:password',
  UPDATE_OWN_USER_PASSWORD = 'update:own:user:password',
  DELETE_ANY_USER = 'delete:any:user',
}

----- src/modules/users/domain/create-user-repository.type.ts -----

import { UserType } from './user.type';

export type CreateUserRepositoryType = Omit<
  UserType,
  'id' | 'createdAt' | 'updatedAt' | 'deletedAt'
>;

----- src/modules/users/domain/index.ts -----

export * from './create-user-repository.type';
export * from './create-user.type';
export * from './update-user.type';
export * from './user-errors.codes';
export * from './user-filter.type';
export * from './user-permissions.enum';
export * from './user-providers.enum';
export * from './user-repository.interface';
export * from './user.type';

----- src/modules/users/domain/user-filter.type.ts -----

export type UserFilterType = {
  id?: number;
  name?: string;
  username?: string;
  email?: string;
  status?: string;
};

----- src/modules/users/domain/user-repository.interface.ts -----

import {
  FindAllFieldsDto,
  FindOneByFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import { UserType } from './user.type';
import { UpdateUserType } from './update-user.type';
import { UserFilterType } from './user-filter.type';
import { CreateUserRepositoryType } from './create-user-repository.type';

export interface UserRepositoryInterface<Entity extends UserType = UserType> {
  findOneBy(
    findOneByFieldsDto: FindOneByFieldsDto<UserFilterType>,
  ): Promise<Entity>;
  findAll(
    findAllFieldsDto?: FindAllFieldsDto<UserFilterType>,
  ): Promise<PaginatedResourceType<Entity>>;
  store(
    createUserFields: CreateUserRepositoryType | CreateUserRepositoryType[],
  ): Promise<Entity | Entity[]>;
  update(id: number, updateUserFields: UpdateUserType): Promise<Entity>;
  delete(id: number): Promise<Entity>;
}

----- src/modules/users/domain/user.type.ts -----

import { PermissionType } from '@modules/permissions/domain';
import { RoleType } from '@modules/roles/domain';

export type UserType = {
  id: number;
  name: string;
  username: string;
  email?: string;
  password: string;
  status: string;
  createdAt: Date;
  updatedAt: Date;
  deletedAt?: Date;
  roles?: RoleType[];
  permissions?: PermissionType[];
};

----- src/modules/users/application/user.policy.ts -----

import { Injectable } from '@nestjs/common';
import { AuthUserType } from '@modules/auth/domain';
import { GeneralPolicy } from '@common/helpers/application';
import { UserType } from '../domain';

@Injectable()
export class UserPolicy extends GeneralPolicy {
  canUpdate(authUser: AuthUserType, targetUser: UserType): boolean {
    return (
      this.hasPermission(authUser.permissions, 'update:any:user') ||
      authUser.info.id === targetUser.id
    );
  }

  canDelete(authUser: AuthUserType): boolean {
    return this.hasPermission(authUser.permissions, 'delete:any:user');
  }

  canView(authUser: AuthUserType, targetUser: UserType): boolean {
    return (
      this.hasPermission(authUser.permissions, 'view:any:user') ||
      authUser.info.id === targetUser.id
    );
  }

  canList(authUser: AuthUserType): boolean {
    return this.hasPermission(authUser.permissions, 'list:any:user');
  }

  canStore(authUser: AuthUserType): boolean {
    return this.hasPermission(authUser.permissions, 'create:any:user');
  }

  canUpdatePassword(authUser: AuthUserType, targetUser: UserType): boolean {
    if (authUser.info.id === targetUser.id) {
      return this.hasPermission(
        authUser.permissions,
        'update:own:user:password',
      );
    }

    return this.hasPermission(authUser.permissions, 'update:any:user:password');
  }
}

----- src/modules/users/application/find-by-user.use-case.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  UserFilterType,
  UserRepositoryInterface,
  UserType,
  userErrorsCodes,
} from '../domain';
import { FindOneByFieldsDto } from '@common/helpers/domain';

export class FindByUserUseCase {
  private readonly context = FindByUserUseCase.name;

  constructor(
    private readonly userRepository: UserRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run({
    filter,
    relations,
  }: FindOneByFieldsDto<UserFilterType>): Promise<UserType> {
    try {
      const user = await this.userRepository.findOneBy({
        filter,
        relations,
      });

      return user;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM011,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/application/delete-user.use-case.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import { UserRepositoryInterface, UserType, userErrorsCodes } from '../domain';

export class DeleteUserUseCase {
  private readonly context = DeleteUserUseCase.name;

  constructor(
    private readonly userRepository: UserRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run(id: number): Promise<UserType> {
    try {
      const user = await this.userRepository.delete(id);

      return user;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM051,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/application/find-all-users.use-case.ts -----

import {
  FindAllFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  UserFilterType,
  UserRepositoryInterface,
  UserType,
  userErrorsCodes,
} from '../domain';

export class FindAllUsersUseCase {
  private readonly context = FindAllUsersUseCase.name;

  constructor(
    private readonly userRepository: UserRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run({
    pagination,
    sort,
    filters,
    relations,
  }: FindAllFieldsDto<UserFilterType> = {}): Promise<
    PaginatedResourceType<UserType>
  > {
    try {
      const userResource = await this.userRepository.findAll({
        pagination,
        sort,
        filters,
        relations,
      });

      return userResource;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM021,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/application/update-user.use-case.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  UpdateUserType,
  UserRepositoryInterface,
  UserType,
  userErrorsCodes,
} from '../domain';

export class UpdateUserUseCase {
  private readonly context = UpdateUserUseCase.name;

  constructor(
    private readonly userRepository: UserRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run(id: number, updateUserFields: UpdateUserType): Promise<UserType> {
    try {
      const user = await this.userRepository.update(id, updateUserFields);

      return user;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM041,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/users/application/index.ts -----

export * from './delete-user.use-case';
export * from './find-all-users.use-case';
export * from './find-by-user.use-case';
export * from './store-user.use-case';
export * from './update-user.use-case';
export * from './user.policy';

----- src/modules/users/application/store-user.use-case.ts -----

import { HashServiceInterface } from '@common/adapters/hash/domain';
import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  CreateUserType,
  UserRepositoryInterface,
  UserType,
  userErrorsCodes,
} from '../domain';
import { FilterRuleEnum } from '@common/helpers/domain';
import { FindAllRolesUseCase } from '@modules/roles/application';
import { FindAllPermissionsUseCase } from '@modules/permissions/application';

export class StoreUserUseCase {
  private readonly context = StoreUserUseCase.name;

  constructor(
    private readonly userRepository: UserRepositoryInterface,
    private readonly findAllRolesUseCase: FindAllRolesUseCase,
    private readonly findAllPermissionsUseCase: FindAllPermissionsUseCase,
    private readonly hashService: HashServiceInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run(createUser: CreateUserType): Promise<UserType> {
    try {
      const { rolesIds, permissionsIds, ...createUserFields } = createUser;

      createUserFields['roles'] = this.validateRoles(rolesIds);
      createUserFields['permissions'] =
        this.validatePermissions(permissionsIds);

      const hashPassword = await this.hashService.hash(createUser.password);

      const user = await this.userRepository.store({
        ...createUserFields,
        status: 'ACTIVE',
        password: hashPassword,
      });

      return user as UserType;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: userErrorsCodes.UM031,
        context: this.context,
        error,
      });
    }
  }

  private async validateRoles(rolesIds: number[]) {
    if (!Array.isArray(rolesIds)) {
      return;
    }

    return await this.findAllRolesUseCase
      .run({
        filters: [
          {
            property: 'id',
            value: rolesIds.join(','),
            rule: FilterRuleEnum.IN,
          },
        ],
      })
      .then((roles) => roles.items);
  }

  private async validatePermissions(permissionsIds: number[]) {
    if (!Array.isArray(permissionsIds)) {
      return;
    }

    return await this.findAllPermissionsUseCase
      .run({
        filters: [
          {
            property: 'id',
            value: permissionsIds.join(','),
            rule: FilterRuleEnum.IN,
          },
        ],
      })
      .then((permissions) => permissions.items);
  }
}

----- src/modules/auth/infrastructure/auth.module.ts -----

import { forwardRef, Module } from '@nestjs/common';
import { UserProvidersEnum } from '@modules/users/domain';
import { FindByUserUseCase } from '@modules/users/application';
import { UserModule } from '@modules/users/infrastructure';
import {
  TokenProvidersEnum,
  TokenServiceInterface,
} from '@common/adapters/token/domain';
import { TokenModule } from '@common/adapters/token/infrastructure';
import {
  HashProvidersEnum,
  HashServiceInterface,
} from '@common/adapters/hash/domain';
import { HashModule } from '@common/adapters/hash/infrastructure';
import {
  LoggerProvidersEnum,
  LoggerServiceInterface,
} from '@common/adapters/logger/domain';
import { LoggerModule } from '@common/adapters/logger/infrastructure';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { ExceptionModule } from '@common/adapters/exception/infrastructure';
import { AuthUseCasesEnum } from '../domain';
import { SignInUseCase } from '../application';
import { SignInController } from './api';

@Module({
  imports: [
    forwardRef(() => UserModule),
    forwardRef(() => TokenModule),
    LoggerModule,
    ExceptionModule,
    HashModule,
  ],
  controllers: [SignInController],
  providers: [
    {
      inject: [
        UserProvidersEnum.FIND_BY_USER_USE_CASE,
        TokenProvidersEnum.TOKEN_SERVICE,
        HashProvidersEnum.HASH_SERVICE,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: AuthUseCasesEnum.SIGN_IN_USE_CASE,
      useFactory: (
        findByUserUseCase: FindByUserUseCase,
        tokenService: TokenServiceInterface,
        hashService: HashServiceInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new SignInUseCase(
          findByUserUseCase,
          tokenService,
          hashService,
          loggerService,
          exceptionService,
        ),
    },
  ],
  exports: [AuthUseCasesEnum.SIGN_IN_USE_CASE],
})
export class AuthModule {}

----- src/modules/auth/infrastructure/decorators/permission-protected.decorator.ts -----

import { SetMetadata } from '@nestjs/common';

export const META_PERMISSIONS = 'permissions';

export const PermissionProtected = <T>(...permissions: T[]) => {
  return SetMetadata(META_PERMISSIONS, permissions);
};

----- src/modules/auth/infrastructure/decorators/get-auth-user.decorator.ts -----

import { AuthUserType } from '@modules/auth/domain';
import { ExecutionContext, createParamDecorator } from '@nestjs/common';

export const GetAuthUser = createParamDecorator(
  (data, ctx: ExecutionContext): AuthUserType => {
    const request = ctx.switchToHttp().getRequest();
    const userInfo = request.user;

    if (!userInfo) {
      throw new Error('User not found');
    }

    return userInfo;
  },
);

----- src/modules/auth/infrastructure/decorators/index.ts -----

export * from './auth.decorator';
export * from './get-auth-user.decorator';
export * from './permission-protected.decorator';

----- src/modules/auth/infrastructure/decorators/auth.decorator.ts -----

import { applyDecorators, UseGuards } from '@nestjs/common';
import { PermissionProtected } from './permission-protected.decorator';
import { JwtAuthGuard, UserPermissionGuard } from '../guards';

export function Auth<T>(...permissions: T[]) {
  return applyDecorators(
    UseGuards(JwtAuthGuard, UserPermissionGuard),
    PermissionProtected<T>(...permissions),
  );
}

----- src/modules/auth/infrastructure/dto/sign-in.dto.ts -----

import { IsNotEmpty, IsString } from 'class-validator';
import { SignInType } from '../../domain';

export class SignInDto implements SignInType {
  @IsNotEmpty()
  @IsString()
  username: string;

  @IsNotEmpty()
  @IsString()
  password: string;
}

----- src/modules/auth/infrastructure/dto/index.ts -----

export * from './sign-in.dto';

----- src/modules/auth/infrastructure/api/sign-in.controller.ts -----

import { Body, Controller, Inject, Post } from '@nestjs/common';
import { RequestId } from '@common/helpers/infrastructure';
import { authErrorsCodes, AuthUseCasesEnum } from '../../domain';
import { SignInUseCase } from '../../application';
import { SignInDto } from '../dto';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';

@Controller()
export class SignInController {
  private readonly context = SignInController.name;
  constructor(
    @Inject(AuthUseCasesEnum.SIGN_IN_USE_CASE)
    private readonly signInUseCase: SignInUseCase,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Post('api/auth/sign-in')
  async run(@RequestId() requestId: string, @Body() signInDto: SignInDto) {
    try {
      return await this.signInUseCase.run(signInDto, requestId);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: authErrorsCodes.AM011,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/auth/infrastructure/api/index.ts -----

export * from './sign-in.controller';

----- src/modules/auth/infrastructure/guards/jwt-auth.guard.ts -----

import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Injectable()
export class JwtAuthGuard extends AuthGuard('jwt') {}

----- src/modules/auth/infrastructure/guards/user-permission.guard.ts -----

import { Reflector } from '@nestjs/core';
import { CanActivate, ExecutionContext, Inject } from '@nestjs/common';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { META_PERMISSIONS } from '../decorators';
import { generalPolicyHelper } from '@common/helpers/application';

export class UserPermissionGuard implements CanActivate {
  private readonly context = UserPermissionGuard.name;

  constructor(
    private readonly reflector: Reflector,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const validPermissions = this.reflector.get<string[]>(
      META_PERMISSIONS,
      context.getHandler(),
    );

    if (!validPermissions || !validPermissions.length) {
      return true;
    }

    const request = context.switchToHttp().getRequest();

    const hasPermission = generalPolicyHelper({
      userPermissions: request.user.permissions,
      validPermissions,
    });

    if (!hasPermission) {
      throw this.exception.forbiddenException({
        message: {
          codeError: 'TKN014',
          message: 'Forbidden',
        },
        context: this.context,
      });
    }

    return true;
  }
}

----- src/modules/auth/infrastructure/guards/index.ts -----

export * from './jwt-auth.guard';
export * from './user-permission.guard';

----- src/modules/auth/infrastructure/index.ts -----

export * from './api';
export * from './auth.module';
export * from './decorators';
export * from './dto';
export * from './guards';

----- src/modules/auth/domain/types/auth.type.ts -----

export type AuthType = {
  accessToken: string;
  expiresIn: number;
  tokenType: string;
};

----- src/modules/auth/domain/types/sign-in.type.ts -----

export type SignInType = {
  username: string;
  password: string;
};

----- src/modules/auth/domain/types/index.ts -----

export * from './auth-user.type';
export * from './auth.type';
export * from './sign-in.type';

----- src/modules/auth/domain/types/auth-user.type.ts -----

import { UserType } from '@modules/users/domain';

export type AuthUserType = {
  info: UserType;
  permissions: string[];
};

----- src/modules/auth/domain/enums/auth-usecases.enum.ts -----

export enum AuthUseCasesEnum {
  SIGN_IN_USE_CASE = 'SIGN_IN_USE_CASE',
}

----- src/modules/auth/domain/enums/index.ts -----

export * from './auth-errors.codes';
export * from './auth-usecases.enum';

----- src/modules/auth/domain/enums/auth-errors.codes.ts -----

export const authErrorsCodes = {
  AM010: {
    codeError: 'AM010',
    message: 'use case SignIn',
  },
  AM011: {
    codeError: 'AM011',
    message: 'controller SignIn',
  },
  AM012: {
    codeError: 'AM012',
    message: 'user or password invalid',
    serverMessage: 'User or password invalid',
  },
};

----- src/modules/auth/domain/index.ts -----

export * from './enums';
export * from './interfaces';
export * from './types';

----- src/modules/auth/domain/interfaces/sign-in-use-case.interface.ts -----

import { AuthType, SignInType } from '../types';

export interface SignInUseCaseInterface<Entity extends AuthType = AuthType> {
  run(userFilters: SignInType): Promise<Entity>;
}

----- src/modules/auth/domain/interfaces/index.ts -----

export * from './sign-in-use-case.interface';

----- src/modules/auth/application/index.ts -----

export * from './sign-in.use-case';

----- src/modules/auth/application/sign-in.use-case.ts -----

import { FindByUserUseCase } from '@modules/users/application';
import { TokenServiceInterface } from '@common/adapters/token/domain';
import { HashServiceInterface } from '@common/adapters/hash/domain';
import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import { AuthType, SignInType, authErrorsCodes } from '../domain';
import { BaseUseCaseInterface, FilterRuleEnum } from '@common/helpers/domain';

export class SignInUseCase
  implements BaseUseCaseInterface<SignInType, AuthType>
{
  private readonly context = SignInUseCase.name;

  constructor(
    private readonly findByUserUseCase: FindByUserUseCase,
    private readonly tokenService: TokenServiceInterface,
    private readonly hashService: HashServiceInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run(
    { username, password }: SignInType,
    requestId: string,
  ): Promise<AuthType> {
    try {
      const usernameType = this.isValidEmail(username) ? 'email' : 'username';

      this.logger.log({
        message: `Sign in with ${usernameType} ${username}`,
        context: this.context,
        requestId,
      });

      const user = await this.findByUserUseCase.run({
        filter: {
          property: usernameType,
          rule: FilterRuleEnum.EQUALS,
          value: username,
        },
      });

      if (!user) {
        throw this.exception.badRequestException({
          message: authErrorsCodes.AM012,
          context: this.context,
        });
      }

      if (!(await this.hashService.compare(password, user.password))) {
        throw this.exception.badRequestException({
          message: authErrorsCodes.AM012,
          context: this.context,
        });
      }

      const { token, tokenExpiration } = this.tokenService.generateToken({
        sub: user.id,
      });

      this.logger.log({
        message: `User with id=${user.id} signed in`,
        context: this.context,
        requestId,
      });

      return {
        accessToken: token,
        expiresIn: tokenExpiration,
        tokenType: 'Bearer',
      };
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: authErrorsCodes.AM010,
        context: this.context,
        error,
      });
    }
  }

  private isValidEmail(email: string): boolean {
    const re =
      /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

    return re.test(email.toLowerCase());
  }
}

----- src/modules/permissions/infrastructure/seeders/permissions.seeder.ts -----

import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { RolePermissionsEnum } from '@modules/roles/domain';
import { UserPermissionsEnum } from '@modules/users/domain';
import {
  PermissionPermissionsEnum,
  PermissionRepositoryInterface,
  PermissionType,
} from '../../domain';

export class PermissionsSeeder {
  private readonly context = PermissionsSeeder.name;

  constructor(
    private readonly permissionRepository: PermissionRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
  ) {}

  async seed(): Promise<PermissionType[]> {
    const permissionPermissions = this.enumToArray(
      PermissionPermissionsEnum,
      'permissions',
    );
    const rolePermissions = this.enumToArray(RolePermissionsEnum, 'roles');
    const userPermissions = this.enumToArray(UserPermissionsEnum, 'users');

    const permissions = await this.permissionRepository.store([
      ...permissionPermissions,
      ...rolePermissions,
      ...userPermissions,
    ]);

    this.logger.debug({
      message: 'Development permissions seeded',
      context: this.context,
    });

    return permissions as PermissionType[];
  }

  private enumToArray<T>(enumObject: T, module: string) {
    return Object.keys(enumObject).map((key) => ({
      name: enumObject[key],
      module,
    }));
  }
}

----- src/modules/permissions/infrastructure/seeders/index.ts -----

export * from './permissions.seeder';

----- src/modules/permissions/infrastructure/persistence/permission.entity.ts -----

import { Column, Entity, ManyToMany, PrimaryGeneratedColumn } from 'typeorm';
import { RoleEntity } from '@modules/roles/infrastructure';
import { UserEntity } from '@modules/users/infrastructure';
import { PermissionType } from '../../domain';

@Entity({ name: 'permissions' })
export class PermissionEntity implements PermissionType {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({
    type: 'varchar',
    length: 100,
    nullable: false,
  })
  name: string;

  @Column({
    type: 'varchar',
    length: 100,
    nullable: false,
  })
  module: string;

  @Column({
    type: 'text',
    nullable: true,
  })
  description: string;

  @ManyToMany(() => RoleEntity, (role) => role.permissions)
  roles: RoleEntity[];

  @ManyToMany(() => UserEntity, (user) => user.permissions)
  users: UserEntity[];
}

----- src/modules/permissions/infrastructure/persistence/permission-typeorm.repository.ts -----

import { Inject } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { In, Repository } from 'typeorm';
import {
  getOrderTypeOrmHelper,
  getWhereTypeOrmHelper,
} from '@common/helpers/infrastructure';
import {
  FindAllFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import {
  LoggerProvidersEnum,
  LoggerServiceInterface,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import {
  PermissionRepositoryInterface,
  PermissionFilterType,
  permissionErrorsCodes,
  CreatePermissionType,
} from '../../domain';
import { PermissionEntity } from './permission.entity';

export class PermissionTypeOrmRepository
  implements PermissionRepositoryInterface<PermissionEntity>
{
  private readonly context = PermissionTypeOrmRepository.name;

  constructor(
    @InjectRepository(PermissionEntity)
    private readonly permissionsRepository: Repository<PermissionEntity>,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async findOneBy(fields: PermissionFilterType): Promise<PermissionEntity> {
    try {
      const Permission = await this.permissionsRepository.findOneOrFail({
        where: { ...fields },
      });

      return Permission;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: permissionErrorsCodes.PRM010,
        context: this.context,
        error,
      });
    }
  }

  async findByIds(ids: number[]): Promise<PermissionEntity[]> {
    try {
      const Permission = await this.permissionsRepository.find({
        where: { id: In(ids) },
      });

      return Permission;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: permissionErrorsCodes.PRM010,
        context: this.context,
        error,
      });
    }
  }

  async findAll({
    pagination,
    sort,
    filters,
    relations,
  }: FindAllFieldsDto<PermissionFilterType> = {}): Promise<
    PaginatedResourceType<PermissionEntity>
  > {
    try {
      const where = getWhereTypeOrmHelper<PermissionFilterType>(filters);
      const order = getOrderTypeOrmHelper<PermissionFilterType>(sort);

      const { page = 1, size } = pagination || {};

      const skip = size && (page - 1) * size;

      const [permissions, count] =
        await this.permissionsRepository.findAndCount({
          where,
          order,
          relations,
          skip,
          take: size,
        });

      const lastPage = size ? Math.ceil(count / size) : 1;

      return {
        total: count,
        currentPage: page,
        lastPage,
        size: size || count,
        items: permissions,
      };
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: permissionErrorsCodes.PRM020,
        context: this.context,
        error,
      });
    }
  }

  async store(
    createPermissionsFields: CreatePermissionType | CreatePermissionType[],
  ): Promise<PermissionEntity | PermissionEntity[]> {
    try {
      if (Array.isArray(createPermissionsFields)) {
        return this.permissionsRepository.save(createPermissionsFields);
      }

      return this.permissionsRepository.save(createPermissionsFields);
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: permissionErrorsCodes.PRM030,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/permissions/infrastructure/persistence/index.ts -----

export * from './permission-typeorm.repository';
export * from './permission.entity';

----- src/modules/permissions/infrastructure/permissions.module.ts -----

import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import {
  LoggerProvidersEnum,
  LoggerServiceInterface,
} from '@common/adapters/logger/domain';
import { LoggerModule } from '@common/adapters/logger/infrastructure';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { ExceptionModule } from '@common/adapters/exception/infrastructure';
import {
  PermissionProvidersEnum,
  PermissionRepositoryInterface,
} from '../domain';
import { FindAllPermissionsUseCase } from '../application';
import { PermissionEntity, PermissionTypeOrmRepository } from './persistence';
import { PermissionsSeeder } from './seeders';
import {
  FindAllPermissionsController,
  // FindByPermissionController,
} from './api';

@Module({
  imports: [
    TypeOrmModule.forFeature([PermissionEntity]),
    LoggerModule,
    ExceptionModule,
  ],
  controllers: [
    FindAllPermissionsController,
    // FindByPermissionController
  ],
  providers: [
    {
      provide: PermissionProvidersEnum.PERMISSION_REPOSITORY,
      useClass: PermissionTypeOrmRepository,
    },
    {
      provide: PermissionProvidersEnum.PERMISSION_SEEDER,
      inject: [
        PermissionProvidersEnum.PERMISSION_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
      ],
      useFactory: (
        permissionRepositoy: PermissionRepositoryInterface,
        loggerService: LoggerServiceInterface,
      ) => new PermissionsSeeder(permissionRepositoy, loggerService),
    },
    {
      inject: [
        PermissionProvidersEnum.PERMISSION_REPOSITORY,
        LoggerProvidersEnum.LOGGER_SERVICE,
        ExceptionProvidersEnum.EXCEPTION_SERVICE,
      ],
      provide: PermissionProvidersEnum.FIND_ALL_PERMISSIONS_USE_CASE,
      useFactory: (
        PermissionRepositoy: PermissionRepositoryInterface,
        loggerService: LoggerServiceInterface,
        exceptionService: ExceptionServiceInterface,
      ) =>
        new FindAllPermissionsUseCase(
          PermissionRepositoy,
          loggerService,
          exceptionService,
        ),
    },
    // {
    //   inject: [
    //     PermissionProvidersEnum.PERMISSION_REPOSITORY,
    //     LoggerProvidersEnum.LOGGER_SERVICE,
    //     ExceptionProvidersEnum.EXCEPTION_SERVICE,
    //   ],
    //   provide: PermissionProvidersEnum.FIND_BY_PERMISSION_USE_CASE,
    //   useFactory: (
    //     PermissionRepositoy: PermissionRepositoryInterface,
    //     loggerService: LoggerServiceInterface,
    //     exceptionService: ExceptionServiceInterface,
    //   ) =>
    //     new FindByPermissionUseCase(
    //       PermissionRepositoy,
    //       loggerService,
    //       exceptionService,
    //     ),
    // },
  ],
  exports: [
    PermissionProvidersEnum.PERMISSION_REPOSITORY,
    PermissionProvidersEnum.FIND_ALL_PERMISSIONS_USE_CASE,
    // PermissionProvidersEnum.FIND_BY_PERMISSION_USE_CASE,
  ],
})
export class PermissionModule {}

----- src/modules/permissions/infrastructure/api/find-all-permissions.controller.ts -----

import { Controller, Get, Inject } from '@nestjs/common';
import {
  FilteringType,
  PaginationType,
  SortingType,
  PaginatedResourceType,
} from '@common/helpers/domain';
import {
  PaginationParams,
  FilteringParams,
  SortingParams,
} from '@common/helpers/infrastructure';
import {
  LoggerServiceInterface,
  LoggerProvidersEnum,
} from '@common/adapters/logger/domain';
import {
  ExceptionProvidersEnum,
  ExceptionServiceInterface,
} from '@common/adapters/exception/domain';
import { Auth } from '@modules/auth/infrastructure';
import {
  PermissionFilterType,
  PermissionPermissionsEnum,
  PermissionProvidersEnum,
  PermissionType,
  permissionErrorsCodes,
} from '../../domain';
import { FindAllPermissionsUseCase } from '../../application';
import { PermissionPresenter } from '../permission.presenter';

@Controller()
export class FindAllPermissionsController {
  private readonly context = FindAllPermissionsController.name;

  constructor(
    @Inject(PermissionProvidersEnum.FIND_ALL_PERMISSIONS_USE_CASE)
    private readonly findAllPermissionsUseCase: FindAllPermissionsUseCase,
    @Inject(LoggerProvidersEnum.LOGGER_SERVICE)
    private readonly logger: LoggerServiceInterface,
    @Inject(ExceptionProvidersEnum.EXCEPTION_SERVICE)
    private readonly exception: ExceptionServiceInterface,
  ) {}

  @Get('api/permissions')
  @Auth<PermissionPermissionsEnum>(PermissionPermissionsEnum.LIST_PERMISSION)
  async run(
    @PaginationParams() paginationParams?: PaginationType,
    @SortingParams<PermissionFilterType>('id', 'name', 'module')
    sortParams?: SortingType<PermissionFilterType>,
    @FilteringParams<PermissionFilterType>('id', 'name', 'module')
    filterParams?: FilteringType<PermissionFilterType>[],
  ): Promise<PaginatedResourceType<Partial<PermissionType>>> {
    try {
      const permissions = await this.findAllPermissionsUseCase.run({
        pagination: paginationParams,
        sort: sortParams,
        filters: filterParams,
      });

      return {
        ...permissions,
        items: permissions.items.map(
          (permission) => new PermissionPresenter(permission),
        ),
      };
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: permissionErrorsCodes.PRM022,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/permissions/infrastructure/api/index.ts -----

export * from './find-all-permissions.controller';

----- src/modules/permissions/infrastructure/permission.presenter.ts -----

import { PermissionType } from '../domain';

export class PermissionPresenter {
  id: number;
  name: string;
  module: string;

  constructor(user: Partial<PermissionType>) {
    this.id = user.id;
    this.name = user.name;
    this.module = user.module;
  }
}

----- src/modules/permissions/infrastructure/index.ts -----

export * from './api';
export * from './permission.presenter';
export * from './permissions.module';
export * from './persistence';
export * from './seeders';

----- src/modules/permissions/domain/permission-providers.enum.ts -----

export enum PermissionProvidersEnum {
  PERMISSION_REPOSITORY = 'PermissionRepository',
  FIND_ALL_PERMISSIONS_USE_CASE = 'FindAllPermissionsUseCase',
  FIND_BY_PERMISSION_USE_CASE = 'FindByPermissionUseCase',
  PERMISSION_SEEDER = 'PermissionSeeder',
}

----- src/modules/permissions/domain/permission-permissions.enum.ts -----

export enum PermissionPermissionsEnum {
  LIST_PERMISSION = 'list:permission',
}

----- src/modules/permissions/domain/permission-errors.codes.ts -----

export const permissionErrorsCodes = {
  PRM010: {
    codeError: 'PRM010',
    message: 'repo findOneBy',
  },
  PRM011: {
    codeError: 'PRM011',
    message: 'use case findOneBy',
  },
  PRM012: {
    codeError: 'PRM012',
    message: 'controller findOneBy',
  },
  PRM020: {
    codeError: 'PRM020',
    message: 'repo findAll',
  },
  PRM021: {
    codeError: 'PRM021',
    message: 'use case findAll',
  },
  PRM022: {
    codeError: 'PRM022',
    message: 'controller findAll',
  },
  PRM030: {
    codeError: 'PRM030',
    message: 'repo store',
  },
};

----- src/modules/permissions/domain/types/permission-filter.type.ts -----

export type PermissionFilterType = {
  id?: number;
  name?: string;
  module?: string;
};

export type PermissionPropertiesType = keyof PermissionFilterType;

----- src/modules/permissions/domain/types/create-permission.type.ts -----

export type CreatePermissionType = {
  name: string;
  module: string;
  description?: string;
};

----- src/modules/permissions/domain/types/permission.type.ts -----

import { RoleType } from '@modules/roles/domain';
import { UserType } from '@modules/users/domain';

export type PermissionType = {
  id: number;
  name: string;
  module: string;
  description?: string;
  roles?: RoleType[];
  users?: UserType[];
};

----- src/modules/permissions/domain/types/index.ts -----

export * from './create-permission.type';
export * from './permission-filter.type';
export * from './permission.type';

----- src/modules/permissions/domain/permission-repository.interface.ts -----

import {
  FindAllFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import {
  CreatePermissionType,
  PermissionFilterType,
  PermissionType,
} from './types';

export interface PermissionRepositoryInterface<
  Entity extends PermissionType = PermissionType,
> {
  findOneBy(fields: PermissionFilterType): Promise<Entity>;
  findByIds(ids: number[]): Promise<Entity[]>;
  findAll(
    findAllFieldsDto: FindAllFieldsDto<PermissionFilterType>,
  ): Promise<PaginatedResourceType<Entity>>;
  store(
    createPermissionsFields: CreatePermissionType | CreatePermissionType[],
  ): Promise<Entity | Entity[]>;
}

----- src/modules/permissions/domain/index.ts -----

export * from './permission-errors.codes';
export * from './permission-permissions.enum';
export * from './permission-providers.enum';
export * from './permission-repository.interface';
export * from './types';

----- src/modules/permissions/application/find-all-permissions.use-case.ts -----

import {
  FindAllFieldsDto,
  PaginatedResourceType,
} from '@common/helpers/domain';
import { LoggerServiceInterface } from '@common/adapters/logger/domain';
import { ExceptionServiceInterface } from '@common/adapters/exception/domain';
import {
  PermissionFilterType,
  PermissionRepositoryInterface,
  PermissionType,
  permissionErrorsCodes,
} from '../domain';

export class FindAllPermissionsUseCase {
  private readonly context = FindAllPermissionsUseCase.name;

  constructor(
    private readonly permissionRepository: PermissionRepositoryInterface,
    private readonly logger: LoggerServiceInterface,
    private readonly exception: ExceptionServiceInterface,
  ) {}

  async run({
    pagination,
    sort,
    filters,
  }: FindAllFieldsDto<PermissionFilterType>): Promise<
    PaginatedResourceType<PermissionType>
  > {
    try {
      const permissionResource = await this.permissionRepository.findAll({
        pagination,
        sort,
        filters,
      });

      return permissionResource;
    } catch (error) {
      throw this.exception.internalServerErrorException({
        message: permissionErrorsCodes.PRM021,
        context: this.context,
        error,
      });
    }
  }
}

----- src/modules/permissions/application/index.ts -----

export * from './find-all-permissions.use-case';
